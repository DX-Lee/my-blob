---
title: TCP RST包
date: 2021-1-10
categories:
 - 网络协议
---

**TCP RST包**

在 TCP 协议中 RST 表示复位，用来**异常的**关闭连接，发送 RST 关闭连接时，不必等缓冲区的数据都发送出去，直接丢弃缓冲区中的数据，连接释放进入`CLOSED`状态。而接收端收到 RST 段后，也不需要发送 ACK 确认。

**RST 出现的原因**

- 端口未监听

  这种情况比较常见，当 web 服务器未启动或者挂掉的时候，客户端使用 connect 重连就会出现

- 连接信息丢失而另一方并不知情

  如果服务器突然断电重启，之前主机上的所有 TCP 连接都丢失了，但是客户端完全不知道这个情况，但客户端继续发送数据给服务端时，服务端没有这条连接的信息，直接返回 RST 包，告知客户端无法处理。

- 调用 close 函数，设置了 SO_LINGER 为 true

  如果设置 SO_LINGER 为 true，linger 设置为 0，当调用 socket.close() 时， close 函数会立即返回，同时丢弃缓冲区内所有数据并立即发送 RST 包重置连接

> RST 包丢失了怎么办？
>
> RST 包是不需要确认的。
>
> 在 RST 包没有丢失的情况下，服务端发送 RST 后马上释放连接，进入 CLOSED 状态，客户端收到 RST 包后也立刻释放连接，进入 CLOSED 状态。
>
> 当 RST 包丢失了，客户端是不知情的，只会认为数据包丢失了会尝试重传，收到 RST 包后释放连接进入 CLOSED 状态，如果 RST 包依旧丢失，会继续重传一定次数后放弃。

**超时重传**

正常发送数据包对端收到后会回复 ACK 包，如果给定时间内未收到会进行重传，重传的时间间隔为 2 的指数级退避，重传的次数tcp_retries 的值决定，会根据 RTO 动态变化。

如果发送 5000 个字节的数据包，因为 MSS 的限制每次传输 1000 个字节，分 5 段传输，如下图

![img](https://user-gold-cdn.xitu.io/2019/2/27/1692f8781978ccc9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

数据包 1 发送的数据正常到达接收端，接收端回复 ACK 1001，表示 seq 为1001之前的数据包都已经收到，下次从1001开始发。 数据包 2（10001：2001）因为某些原因未能到达服务端，其他包正常到达，这时接收端也不能 ack 3 4 5 数据包，因为数据包 2 还没收到，接收端只能回复 ack 1001。

第 2 个数据包重传成功以后服务器会回复5001，表示seq 为 5001 之前的数据包都已经收到了。

由于重传的时间间隔要等几百毫秒才会进行第一次重传，于是有了 **快速重传**：快速重传的含义就是当发送端收到3个或以上的重复的 ACK 后，就意识到之前发的包可能丢了，于是马上重传，不用等超时才重传。

但是这里有个问题：快速重传只能知道需要重传，但是不知道哪个包需要重传，因为发送 3，4，5号包收到的 ack 都是 1001, 除了2号包可能丢失，3，4，5号包也可能丢失。

所以 **SACK** （Selective Acknowledgement）就派上用场。

- 在收到3包的 ACK 包中告诉发送端 当前收到的最大包序列号是 1000 （ack=1001）, [1,1001]、[2001,3001]区间内的包也收到了
- 在收到4包的 ACK 包中告诉发送端 当前收到的最大包序列号是 1000 （ack=1001）, [1,1001]、[2001,4001]区间内的包也收到了
- 在收到5包的 ACK 包中告诉发送端 当前收到的最大包序列号是 1000 （ack=1001）, [1,1001]、[2001,5001]区间内的包也收到了

这样发送端就知道 2 号包丢了，只需要传2号包就可以了。

<img src="https://user-gold-cdn.xitu.io/2019/2/27/1692f878596b44a2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:50%;" />

**重传间隔**

**RTO(Retransmission TimeOut)** 超时重传时间，这个时间不是一成不变的，它会随着不同的网络情况动态进行调整，它与 RTT (Round-trip Time) 密切相关。下面是几种计算 RTO 的方法



- **经典方法** （适用于 RTT 波动较小的情况）

  经典算法引入了 **平滑往返时间 SRTT (Smoothed round trip time)** 的概念: 经过平滑后的 RTT 的值，每测量一次 RTT 就对 SRTT 作一次更新。

  ```
  SRTT = ( α * SRTT ) + ((1- α) * RTT)
  ```

  α 是平滑因子，建议值是0.8 ~ 0.9。假设平滑因子 α = 0.8，那么 SRTT = 80% 的原始值 + 20% 的新采样值。相当于一个低通滤波器

  <img src="https://user-gold-cdn.xitu.io/2019/4/5/169ee07ddc1eb50a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:50%;" />

  当 α 趋向于 1，1 - α 趋向于0，SRTT 就趋向于上一次 SRTT 的值，与新的 RTT 关系就越小，表现出来的就是对短暂的时延变化不敏感

  当 α 趋向于 0，1 - α 趋向于1，SRTT 就趋向于新采样的 RTT 的值，与旧的 SRTT 关系就越小，表现出来的就是对短暂的时延变化更加敏感，更够快速的跟随时延的变化而变化 

  重传时间 RTO 的公式是

  ```
  RTO = min(ubound, max(lbound, β * SRTT))
  ```

  β 为加权因子，一般推荐值为 1.3~2.0 ，ubound 为 RTO 的上边界，lbound 为 RTO 的下边界，公示的含义其实就是 RTO 是 一个 1.3 到 2.0 倍的 SRTT 值，最大不超过 ubound, 最小不低于 lbound。

  这个算法下 平滑因子 α 取值范围是 0.8 ~ 0.9 ，RTT 的变化对 RTO 影响太小了，在相对稳定的网络中这个算法表现还算可以，但是在一个 RTT 变化较大的环境中效果就比较差。

- **标准算法**

  传统方法最大的问题是RTT 有大的波动时，很难即时反应到 RTO 上，因为都被平滑掉了。标准方法对 RTT 的采样增加了一个新的因素

  公式如下

  ```
  SRTT = (1 -  α) * SRTT +  α * RTT
  RTTVAR = (1 - β) * RTTVAR + β * (|RTT-SRTT|) 
  RTO= µ * SRTT + ∂ * RTTVar
  ```

  先看第一个公式：

  ```
  SRTT = (1 -  α) * SRTT +  α * RTT
  ```

  和经典算法一样的，区别是，α 的建议值是 0.125，这种情况下 SRTT = 87.5%的原始值 + 12.5%的新采样值 

  第二个公式：计算 **RTTVAR**：「已平滑的 RTT 平均偏差估计器」（round-trip time variation，RTTVAR）

  ```
  RTTVAR = (1 - β) * RTTVAR + β * (|RTT-SRTT|) 
  ```

  平均偏差是标准方差的良好近似，计算较为容易，无需标准方差的求平方根运算。如果 β 取建议值 0.25 则 RTTVAR = 75%的原始值 + 25%的 平滑 SRTT 与 最新测量 RTT 的差值

  第三个公式计算最终的 RTO：

  ```
  RTO= µ * SRTT + ∂ * RTTVar
  ```

  μ 建议取 1，∂ 建议值取 4，则 RTO = SRTT + 4 RTTVAR

  这种算法下 **RTO 与 RTT 变化的差值关系更密切，能对变化剧烈的 RTT做出更及时的调整。**

- **重传二义性和 Karn / Partridge 算法**

  前面的方法没有解决对于重传的情况下如何计算 RTT （时间戳可以解决）

  - 既然不能确定 ACK 包到底对应重传包还是非重传包，那这次就忽略吧，这次重传的 RTT 不会被用来更新 SRTT 及后面的 RTO
  - 只有当收到未重传过的某个请求的 ACK 包时，才更新 SRTT 等变量并重新计算RTO

  仅仅有上面的规则是远远不够的，放弃掉重传那次不管看起来就像遇到危险把头埋在沙子里的鸵鸟。如果网络抖动，倒是突然出现大量重传，但这个时候 RTO 没有更新，就很坑了，本身 RTO 就是为了自适应网络延迟状况的，结果出问题了没有任何反应。这里 Karn 算法采用了出现重传就将 RTO 翻倍的方法，这就是我们前面看到过的指数级退避（Exponential backoff）。这种方式比较粗暴，但是非常简单。

**总结**

​	RST出现的原因：

		1. 端口未监听
  		2. 连接丢失而另一端并不知情继续发送数据
  		3. SO_LINGER 设置丢弃缓冲区数据，立刻 RST

快速重传 ACK

计算重传间隔的算法：

​	1. 经典算法：适用于 RTT 波动较小的情况下

​	2. 标准算法：在 RTT 波动较大的情况下有更好的适应效果。