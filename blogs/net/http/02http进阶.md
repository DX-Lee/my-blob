---
title: HTTP 进阶
date: 2021-1-18
tags:
 - HTTP
categories:
 - 网络协议
---

#### HTTP 实体数据

HTTP 支持多种数据格式，但是要怎么知道是哪种数据格式呢？HTTP 使用了 **”多媒体邮件扩展“ （Multipurpose Internet Mail Extensions）** 这个标准规范中的一部分作为标识 body 数据类型。经常见到的类型有：

1. text : 即文本格式的可读数据，text/html 表示超文本文档；text/plain 表示纯文档；text/css 样式表等
2. image: 即图像文件，例如 image/png，image/gif，image/jpeg
3. audio/video: 音频和视频数据，例如 audio/mpeg，video/mp4
4. application: 数据格式不固定可能是文本也可能是二进制数据，必须由上层应用程序来解释。常见的有 application/json，application/javascript，application/pdf等，例外如果实在不知道是什么类型，就会是 application/octet-stream，即不透明的二进制数据。

仅有数据格式还不够，HTTP为了在传输过程中节省带宽，还会压缩数据。还需要一个 "Encoding type"，常见的有以下几种：

1. gzip: GNU zip 压缩格式，也是互联网上最流行的压缩格式
2. deflate: zlib (deflate) 压缩格式，流行程度仅次于 gzip
3. br: 一种专门为 HTTP 优化的新压缩算法 （Brotil）

**数据类型**

HTTP 协议定义了两个 **Accept** 请求头和两个 **Content** 响应头，用于客户端和服务端进行 “内容协商”。客户端在 Accept 头告诉服务器希望接收到什么样的数据，服务器在 Content 头里告诉客户端实际发送了什么数据。

**Accept** 字段标记的是客户端可理解的 MIME type，可以用 **“,”** 做分隔列出多种类型，让服务器有更多选择的余地。

```
Accept: text/plain,text/html,application/json,image/png
```

服务器在响应报文的头字段 **Content-Type** 中告诉客户端实体数据的实际类型

```
Content-Type: text/html
```

**Accept-Encoding** 字段标记的是客户端支持的压缩格式

```
Accept-Encoding: gzip, deflate, br
```

**Content-Encoding** 表示的是服务器实际使用的压缩格式

```
Content-Encoding: gzip
```

**语言类型和编码**

不同国家地区使用的自然语言不同，怎么让浏览器显示出每个地区都可以理解阅读的语言文字呢？这实际上就是解决国际化问题，HTTP 引入了语言类型和字符集。

**Accept-Language** 标记了客户端可理解的自然语言，用 **"-"** 分隔而不是用 **"/"** 

```
Accept-Language: zh-CN,zh,en
```

相应的服务端响应头中用 **Content-Language** 指明实体数据的语言类型

```
Content-Language: zh-CN
```

字符集使用的请求头字段是 **"Accept-Charset"** ，但是响应头里没有对应的Content-Charset，而是在 **Content-Type** 字段后面 用 **"charset=xxx"** 来表示

```
Accept-Charset: gbk,utf-8
Content-Type: text/html;charset=utf-8
```

**内容协商的质量值**

在 HTTP 协议里用 Accept、Accept-Encoding、Accept-Language 等请求头字段进行内容协商的时候，还可以用一种特殊的“q”参数表示权重来设定优先级，这里的“q”是“quality factor”的意思。

权重的最大值是 **1**，最小值是 0.01，默认值是 **1**，如果值是 **0** 就表示拒绝。具体的形式是在数据类型或语言代码后面加一个“;”，然后是“q=value”

```
Accept: text/html,application/xml;q=0.9,*/*;q=0.8
```

**内容协商的结果**

内容协商的结果是不透明的，有的时候服务器会在响应头字段里加 **Vary** 字段表示内容协商参考的请求头字段

```
Vary: Accept-Encoding,Accept
```

这个 Vary 字段表示服务器依据了 Accept-Encoding、User-Agent 和 Accept 这三个头字段，然后决定了发回的响应报文。

Vary 字段可以认为是响应报文的一个特殊的“版本标记”。每当 Accept 等请求头变化时，Vary 也会随着响应报文一起变化。也就是说，同一个 URI 可能会有多个不同的“版本”，主要用在传输链路中间的代理服务器实现缓存服务。

#### HTTP 处理大文件传输

对于几百M 甚至 几G的大文件一口气传输过来是不现实的，会等待很长的时间。那么如何在有限的带宽下高效快捷的传输这些大文件呢？

**数据压缩**

可以将数据经过压缩之后再传输。但是这个方法有缺陷：gzip 对于文本文件有较好的压缩率，但是对于图片、音频视频等已经经过高度压缩的数据就没有办法了。

**分块传输**

将大文件分成多个小块，把这些小块发给浏览器，浏览器再进行组装。这种思想再 HTTP 里的实现就是 **”chunked"** 分块传输，响应报文里面用 **“Transfer-Encoding：chunked"** 来表示报文里 body 数据不是一次性发过来的，而是分成多个块（chunked）发送过来。

**“Transfer-Encoding: chunked” **和 **“Content-Length”**这两个字段是**互斥的**，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知。

分块传输的编码规则：

1. 每个分块包含两部分：长度头和数据块
2. 长度头用 **16进制的数字** 表示长度，以CRLF （回车换行，即 \r\n）结尾
3. 数据块紧跟在长度头后面，最后也用 CRLF 结尾，数据不包括CRLF
4. 最后用一个长度为 0 的块表示结束，即 **”0\r\n\r\n"**

**范围请求**

有了分块传输，服务器就可以轻松的收发大文件了，但是对于想要获取大文件的部分数据的场景时，例如观看视频时想要拖动进度条快进几分钟，这个时候分块传输是不能处理的。

为了满足这样的需求，HTTP 允许客户端再请求头使用专门的字段来表示只获取文件的一部分，即 “**范围请求**”。但是范围请求不是 WEB 服务器必备的能力，可以实现也可以不实现。所以服务器必须在响应头里加上 **"Accept-Ranges: bytes"** 来表示自己是支持范围请求的。

对于不支持范围请求的服务器，可以发送 **"Accept-Ranges: none"** 或者干脆不发送该字段，这样客户端就会认为服务器不支持范围请求，老老实实收发整块文件。

请求头 **Range** 是 HTTP 范围请求的专门字段，格式为 **bytes=x-y**，x 和 y 指的是以 **字节** 为单位的请求范围。

注意 x 和 y 表示的是偏移量，范围必须从 0 开始计数。如前十个字节：“0-9”

起点x 和 终点y 也可以省略，这样能够很方便的表示正数或倒数的范围：

- “0-” 表示从文档起点到文档终点，相当于整个文件
- "10-" 表示从第10个字节开始到文档终点
- “-1” 表示文档最后一个字节
- “-10”表示文档末尾的10个字节

服务器接收到 **Range** 字段后首先需要检查范围是否合法，如果超出范围会返回状态码 **416**，如果合法服务器就会根据偏移量读取文件片段，返回状态码 **206**，表示body 数据是原数据的一部分。同时在要在响应头字段 **Content-Range** 中告诉片段实际偏移量和总数据大小，格式为 **”bytes x-y/length**，例如对于原数据为100字节大小的 “0-10”的范围请求，值就是 “bytes 0-10/100"

**多段数据**

范围请求还可以同时请求多个片段，在 Range 头里加多个 ”x-y“，这种情况需要使用一种特殊的 MIME 类型：**“multipart/byteranges”** ，表示报文的body 是由多段字节序列组成的，并且还要用一个参数 **boundary=xxx**, 给出段之间的分隔标记。

每一个分段必须以**“- -boundary”**开始（前面加两个“-”），之后要用**“Content-Type”**和**“Content-Range”**标记这段数据的类型和所在范围，然后就像普通的响应头一样以回车换行结束，再加上分段数据，最后用一个“**- -boundary- -**”（前后各有两个“-”）表示所有的分段结束。

例如：

请求

```
GET /16-2 HTTP/1.1
Host: www.chrono.com
Range: bytes=0-9, 20-29
```

响应

```
HTTP/1.1 206 Partial Content
Content-Type: multipart/byteranges; boundary=00000000001
Content-Length: 189
Connection: keep-alive
Accept-Ranges: bytes
 
 
--00000000001
Content-Type: text/plain
Content-Range: bytes 0-9/96
 
// this is
--00000000001
Content-Type: text/plain
Content-Range: bytes 20-29/96
 
ext json d
--00000000001--
```

#### HTTP 连接管理

HTTP 最初（0.9/1.0）整个连接很短暂，发送请求，接收到请求之后连接就会关闭。这样每次请求都需要进行 tcp 三次握手，四次挥手，开销太大。于是提出了 **长连接**。HTTP 1.1版本中的连接都会默认开启长连接，只要 HTTP 向服务器发起了第一次请求，后续的请求都会重复利用这个连接。

当然我们也可以在 请求头里明确要求使用长连接的机制。这个头字段是 **Connection**，值是 **keep-alive**。不过不管客户端是否显示要求启用长连接，如果服务端支持长连接，都会在响应头里加上 **Connection: keep-alive** 字段告诉客户端是支持长连接的。

不过长连接也不能一直保持连接下去，这样如果有大量的长连接只连不发，很快就会耗尽服务器资源，因此需要在适当的时候关闭。

客户端可以在请求头中加上 **Connection: close** 字段表示这次通信后关闭连接。服务器收到这个字段之后就知道客户端要主动关闭连接，于是也在响应头中加上这个字段，发送之后断开连接。

**队头阻塞**

**队头阻塞** 与长连接和短连接无关，是由于 HTTP 的请求-应答 模型导致的。

因为 HTTP 要求必须 **”一收一发“**，这就形成了一个先进先出的串行队列，队列中的请求没有轻重缓急的优先关系，排在最前面的请求优先处理，处理完之后才能处理下一个请求。如果队首的请求太慢，就会阻塞后面的请求处理。

对此，HTTP 使用了以下解决方案

1. **并发连接** ：也就是同时对一个域名发起多个长连接，用数量解决质量问题。但是不能建立很多连接，现在浏览器一般限制在 6 ~8个，chrome 是 6 个。
2. **域名分片** ：多开几个域名，而这些域名又指向同一台服务器，这样实际的连接数量又上去了。

#### HTTP Cookie

HTTP 是一个无状态协议，但是有时候需要保存一些状态，为此引入了 **cookie**。

Cookie 本质上就是浏览器存储的一个很小的文本信息，以key-value的方式存储。服务器通过 **Set-Cookie** 头字段写入cookie，浏览器收到响应报文后会把 cookie 保存下来，下次请求的时候会自动带上，放在请求头 **Cookie** 字段里。服务器可以在头字段添加多个 **Set-Cookie** 写入多个 cookie，浏览器发送时不需要发送多个 **Cookie** 字段，只需要在一行里用 **“；”** 隔开

**cookie 的属性**

cookie 实际上就是服务器委托浏览器存储在客户端里的一些数据，通常这些数据都会记录用户的相关识别信息，因此需要使用一些手段来保护 cookie ，防止外泄或窃取。

1. **设置生命周期**：Cookie 可以设置有效期，超过期限浏览器就会把它从存储中删除，不会发送给服务端。

   有效期可以使用 **Max-Age** 和 **Expires** 来设置

   **Expires** ，即过期时间。用的是绝对事件点，可以理解为截至日期；**Max-Age** ，失效时长，使用的是相对时间，单位为 **秒**，浏览器收到报文的时间加上 Max-Age 的时间，就是失效的时间。

   当 **Expires** 和 **Max-Age** 同时出现时，浏览器会优先考虑 Max-Age

2. **设置作用域**：让浏览器只发给特定的服务器和 URI。

   **Domain** 和 **Path** 可以指定 cookie 所属的域名和路径。在发送请求之前，浏览器会提取当前 URL 中的 host 和 path 部分，对比 cookie 的 属性，如果不匹配就不会发送 cookie

3. **安全**：

   js 可以通过 document.cookie 读取 cookie 的值，容易收到 **XSS 攻击（"跨站脚本攻击"）** ，可以设置 **HttpOnly**，告诉浏览器此 cookie 只能通过 HTTP 协议传输，禁止其他方式访问。

   另一个属性 **SameSite**，可以防范 **XSRF 攻击 （”跨域请求伪造“）**，共有三种属性

   1. **strict** : 这个最为严格，禁止跨站请求发送cookie
   2. **lax**：这个稍微宽松一点，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。
   3. **none**：请求会自动带上。

   还有一个属性 **Secure**，表示只在 HTTPS 协议加密传输，明文的 HTTP 会禁止发送，但 Cookie本身不是加密的，依旧是明文。

**cookie的缺点**

1. 容量缺陷：cookie大小一般只有 4kb，每个domain最多只能由 20 条cookie
2. 安全缺陷：以明文的形式保存在客户端，不能存储敏感信息，如果不设置 HttpOnly ，可以通过 js 获取。
3. 性能缺陷：cookie 紧跟域名，每次请求时都会带上cookie，随着请求数量的增多会造成性能浪费。但是可通过指定 domain 和 path 来解决。

#### HTTP 缓存控制

浏览器使用 HTTP 获取资源的成本较高，所以有必要把数据缓存起来，下次请求时尽可能地复用，这样可以有效避免多次请求应答的成本，节约网咯带宽，加快响应速度。

缓存可大致分为 **客户端缓存** 和 **服务端缓存**

**客户端缓存**

**服务器的缓存控制**

服务器标记资源有效期使用的头字段是 **Cache-Control**，里面的值 **max-age**，表示资源的有效期。



> 除了 Cache-Control 头字段外，还有 Expires 头字段，值是过期时间，表示在这个过期时间之前可以继续使用缓存，优先级要低于 Cache-Control。
>
> 由于Expires 的值是服务器的时间，而服务器和客户端的时间可能并不一致，所以这个过期时间可能就不准确。因此在 HTTP1.1 中被抛弃了。还有一个历史遗留字段 “Pragma: no-cache"，相当于 ”Cache-Control：no-cache“，除非为了兼容 HTTP1.0 否则不建议使用。



**注意：资源生存时长计算时间起点是服务端生成响应报文的时刻（即 Date 字段，也就是离开服务器的时刻），不是客户端收到报文时刻**。也就是说包含了在链路传输过程中所有节点停留的时长，如果 max-age = 5，由于网络状况较差，客户端收到报文的时候已经过去了3 秒，那么这个资源在客户端最多只能存活 2 秒。

除了 max-age，在响应报文中还能用其他属性来更精确得到指示浏览器如何使用缓存：

- **no_store**：表示不允许缓存。用于变化非常频繁的页面，如秒杀页面
- **no_cache**：这个字段与no_store 字段容易弄混，实际上不是允许缓存，而是**可以缓存**，只是每次在使用之前都需要向服务器验证是否可用。
- **must-revalidate**：他的意思是缓存不过期就可以使用，如果过期就需要去服务器验证

**浏览器的缓存控制**

有了缓存之后是否就可以直接用了呢？假如你在浏览器里点几次刷新按钮，会发现页面并没有被缓存。这是为什么呢？

其实不只是服务器可以发 **Cache-Control**，客户端也可以发送，也就是说请求-应答双方都可以用这个字段进行缓存控制，互相协商缓存的使用策略。

当你点击刷新的时候，浏览器会在请求头里加一个 **Cache-Control: max-age=0**，max-age=0意思要最新的数据，因此浏览器不会使用缓存，而是向服务器发送请求，服务器看到 max-age=0 ，也会生成最新的报文回复给浏览器。

**ctrl + F5** 强制刷新又是怎样的呢？其实就是 **Cache-Control: no_cache**，含义与 max-age=0，一样看后台服务器怎么理解，通常效果都是一样的。

条件请求

缓存没过期时可以直接使用，如果过期就要去服务器验证是否可用。常用头字段有 **If-Modified-Since** 和 **If-None-Match** 两个。

服务器第一次响应报文中会提供 **Last-Modified** 和 **Etag** 两个头字段，第二次请求时就会带上缓存的原值，验证资源是否是最新的。如果资源没有变，服务器会返回 **304**，表示缓存依旧有效，客户端只需要更新一下有效期就可以继续使用。

**Last-Modified** ：表示文件的最后修改时间

**Etag**：是服务器根据当前资源生成的一个唯一标识。这个字段是 **Last-Modified** 能够感知的单位是秒级，如果在一秒内修改了多次，那么是无法区分的；其次 如果资源修改时间更新了但是内容并没有变化，也会造成缓存失效。

**Etag 还有"强"，"弱"之分**。强 ETag 要求资源在字节级别必须完全相符，弱 ETag 在值前有个“W/”标记，只要求资源在语义上没有变化，但内部可能会有部分发生了改变（例如 HTML 里的标签顺序调整，或者多了几个空格）。

#### HTTP 代理

HTTP 基于“请求-应答”的模型，协议中只有两个互相通信的角色，一个是请求方（浏览器），另一个是应答方（服务器），但有特殊情况，就是代理服务器。**代理服务** 其实就是客户端和服务端通信链路中插入的一个中间环节，也是台服务器，对于客户端，表现为服务器，代源服务器响应请求；对于服务端，表现为客户端，代客户端发送请求，具有双重身份。

**代理服务作用**

1. **负载均衡**：由于在面向客户端时屏蔽了源服务器，客户端看到的只是代理服务器，背后有多少台源服务器，是哪些 IP 地址都是不知道的，因此由代理服务器掌握分发请求的大权，通过一些算法将请求合理的分散到不同的服务器，提高系统整体资源的利用率和性能。负载均衡的算法有：**轮询**，**随机**，**一致性哈希**等。
2. **安全防护**: 利用“心跳”等机制监控后端服务器，发现有故障就及时“踢出”集群，保证服务高可用；保护被代理的后端服务器，限制 IP 地址或流量，抵御网络攻击和过载；拦截上下行的数据，任意指定策略修改请求或者响应等
3. **内容缓存**：暂存复用服务器响应。

**代理相关头字段**

前面提到代理服务器隐藏了真实的客户端和服务端，那么如果双方想要获得这些原始信息该怎么办呢？

**Via** ：这个字段用来记录经过的代理服务器。当报文每经过一个代理节点，代理服务器就会把自身的信息（主机名或者域名）追加到字段的末尾，这样到达对端时就可以根据这个字段知道报文经过了哪些环节才到达目的地。

例如 

> 客户端 -> 代理1 -> 代理2 -> 服务器

服务器拿到的报文里 Via 字段的值为 proxy1,proxy2

客户端拿到的报文里 Via 字段的值就是 proxy2,proxy1

Via 字段只能知道客户端和服务端之间是否存在代理，还不能知道对方的真实身份。一般来说服务器的 IP 地址应该是保密的，关系到内网安全，一般不会让客户端知道，但是反过来服务端通常需要知道客户端真实 IP 地址。常用的两个头字段是 **”X-Forwarded-For"** 和 **“X-Real-IP"** 。

**X-Forwarded-For** : 这个字段与 ”Via" 类似，只不过它追加的信息不是代理主机名，而是请求方的 IP 地址，所以在字段最左边的就是客户端的地址。

**X-Real-IP**：另一种获取客户端真实 IP 的手段。它只记录客户端的 IP 地址，没有中间的代理信息。相当于 X-Forward-For 的简化版，如果客户端与服务器之间只有一个代理，那么 X-Forward-For 和 X-Real-IP 两个字段的值是一样的。

 **X-Forward-Host , X-Forward-Proto**：与 X-Real-IP 类似，只记录客户端请求的原始域名和协议名。

**代理协议**

有了 X-Forwarded-For 等头字段，服务器就可以拿到客户端准确的数据了。但是对于代理服务器来说操作 X-Forwarded-For 等头字段必须要解析 HTTP 头，成本比较高，会降低代理的转发性能。另一个问题是 X-Forwarded-For 等头必须修改原始报文，在有些情况写是不允许甚至是不可能的，比如（HTTPS通信被加密）

于是出现了专门的**代理协议（The PROXY protocal）**。

代理协议有 v1 和 v2 两个版本，v1 使用明文，v2使用二进制格式。

v1 版本只需要在 HTTP 报文前加一行 ASCII 码文本，相当于多了一个头

这一行文本其实非常简单，开头必须是“PROXY”五个大写字母，然后是“TCP4”或者“TCP6”，表示客户端的 IP 地址类型，再后面是请求方地址、应答方地址、请求方端口号、应答方端口号，最后用一个回车换行（\r\n）结束。

```
// PROXY + TCP4/TCP6 + 请求方地址 + 接收方地址 + 请求方端口号 + 接收方端口号
PROXY TCP4 1.1.1.1 2.2.2.2 55555 80\r\n
GET / HTTP/1.1\r\n
Host: www.xxx.com\r\n
\r\n
```

**缓存代理**

不仅客户端可以缓存，服务器也可以缓存，让请求不必走完整个后续处理过程，“就近”获得响应结果。

HTTP 服务器缓存功能主要由代理服务器来实现。

当代理服务器不缓存的时候，充当的只是一个中转站。加入缓存后就不一样了，代理服务器收到服务端发来的响应数据后，需要做两件事：一是将响应发给客户端，而是把报文缓存下来。下次再有同样的请求，代理服务器可以直接发送304或者缓存数据，不必再从源服务器获取，这样就降低了客户端的等待时间，也节省了源服务器的网络带宽。

代理服务器面向客户端和服务端，既可以使用客户端的缓存控制策略，也可以使用服务端的缓存控制策略。也就是说可以同时使用 **Cache-Control ** 的各种属性。但是代理服务器只是一个数据中转站，还需要新的 Cache-Control 属性对它进行约束.

**private和public**

**private** 表示缓存只能再客户端保存，不能放在代理上使用；**public** 表示缓存时公有的，谁都可以用。

**must-revalidate 和 proxy-revalidate**

缓存失效后的验证也需要分开。**must-revalidate** 表示只要过期就要去源服务器验证，**proxy-revalidate** 表示代理的缓存过期后去源服务器上验证，客户端只需要验证到代理这个环节就可以了

**s-maxage**

"s" 意思是 share ,只限定在代理的缓存能够存多久，客户端依旧使用 max-age

**no-transform**

代理有时候会对缓存下来的数据进行优化，比如把图片生成png, webp 等几种格式，方便今后的请求。“no-transform" 不允许这样做，不能对缓存数据进行改动。

**客户端缓存控制**

对于客户端新增了两个属性 **max-stale** 和 **min-fresh**

**max-stale** 表示代理上的缓存过期了也能接受，但不能过期太多，超过 x 秒后也不要；**min-fresh** 表示缓存必须有效，而且必须在 x 秒后也必须有效。

 **if-only-cached** 

表示只接受代理缓存的数据，不接受源服务器的响应，如果代理上没有缓存或者缓存过期，应该给客户端返回一个 **504 (Gateway Timeout)**
