---
title: 浏览器内存回收
date: 2021-2-6
categories:
 - 浏览器
---

首先来了解一下JavaScript 的数据是怎么存储的。

JavaScript 在执行过程中有三种内存空间：代码空间、栈空间和堆空间。

- 代码空间

  用来存储可执行代码

- 栈空间

  即调用栈，用来存储执行上下文。执行上下文中保存 **原始类型** 的数据，引用类型的数据保存在堆空间，执行上下文中变量保存的其实是内存地址。

- 堆空间

  用来保存引用类型的数据。

>  闭包
>
> 前面提到原始类型的数据保存在栈空间，引用类型保存在堆空间，那么对于闭包中的数据保存在哪里呢？
>
> 实际上JavaScript 引擎在编译的时候，会对函数的内部函数进行词法扫描，如果发现其引用了外部变量，JavaScript 引擎就会判断其是一个闭包，会在堆空间中创建一个 “closure" 的内部对象，将引用的变量保存起来，如果还引用了其他的外部变量，也会被添加到 closure 对象中。
>
> 因此当执行上下文销毁的时候，闭包中的变量依然保存在内存中。

**垃圾回收**

- 栈空间内存回收，是销毁执行上下文。调用栈中有一个记录当前执行状态的指针（ESP），当函数执行完后，需要销毁当前执行上下文，只需要将ESP 指针下移。后来新的执行上下文会直接覆盖掉原来的内容。

- 堆空间内存回收

  首先了解 **代际假说**，后续的垃圾回收策略都是建立在该假说的基础上。

  **代际假说** 有两个特点：

  1. 大多数对象在内存中存活时间很短，简单来说很多内存一经分配很快就会变得不可访问
  2. 不死的对象会存活更久

V8 中把堆分为两部分：**新生代** 和 **老生代**。**新生代中存放的是生存时间比较短的对象，老生代存放的是生存时间比较长的对象**

新生代的容量比较小，一般只有1~8M 的容量，而老生代中支持的容量就比较大了，对于这两个区域，V8 分别使用了两个垃圾回收器：

- **主垃圾回收器：用来回收老生代中的内存**
- **副垃圾回收器：用来回收新生代中的内存**

垃圾回收器通常都有一套共同的执行流程：

1. 标记内存空间中可回收对象和不可回收对象
2. 回收可回收对象占用的内存。其实就是在所有标记完成后，一次性清理可回收对象。
3. 内存整理。这一步是可选的，一般来说频繁的回收内存之后，内存中会产生大量的不连续空间，**即内存碎片**。当要分配较大的内存对象时可能会出现内存不足的情况，因此需要整理这些内存碎片。

副垃圾回收器：

​	新生代用 **Scavenge** 算法，即将新生代区域对半划分为两个区域：对象区域和空闲区域。

​	新产生的对象会被放入对象区域，当对象区域快要满的时候会进行一次垃圾回收。

​	垃圾回收过程中，先对对象区域中的垃圾作标记，标记完成后，进入垃圾清理阶段，将存活的对象复制到空闲区域，同时也会把这些对象有序的排列起来，相当于完成了内存整理的工作。复制完成后将空闲区域和对象区域进行角色反转，即原来的对象区域变成空闲区域，空闲区域变成对象区域，这样就完成了垃圾回收的操作。由于每次垃圾回收过程中都需要将存活的对象复制到空闲区域，需要时间成本，如果区域设置过大就会影响执行效率，因此新生代区域一般设置的比较小。

也正是因为新生代的空间不大，很容易就被存活的对象占满，为此 JavaScript 引擎使用了 **对象晋升策略**。经过两次垃圾回收还存活的对象会晋升到老生代中。

主垃圾回收器：

​	老生代中除了新生代晋升过来的对象，还有一些比较大的对象会直接被分配到老生代中。因此老生代中对象的特点时占用空间比较大，存活时间长。

​	因此主垃圾回收器使用的 **标记-清除算法**来进行垃圾回收。将内存中的垃圾数据进行标记，清除阶段将标记的对象清除。不过对一块内存多次进行标记清除算法后会产生大量内存碎片，因此又出现了 **标记-整理算法**。标记阶段仍然与标记清除算法阶段一样，但后续清理过程不是直接对可回收对象进行清理，而是让所有可存活对象往一边移动，然后直接清除边界外的内存。

**全停顿**

当执行垃圾回收算法时，需要将正在执行的 JS 脚本暂停，等垃圾回收完成之后在恢复执行，这种行为称作 **全停顿**。

V8新生代执行垃圾回收时，由于空间较小，存活的对象较少，全停顿带来的影响不大。但对于老生代来说，全停顿会造成页面卡顿。

为了降低全停顿带来的影响，V8**使用了增量标记算法**，将标记过程分为一个个子标记过程，同时让垃圾回收标记和 JS 应用逻辑交替执行，知道标记阶段完成。这样将一个完整的垃圾回收过程拆分为许多个小的子任务，而子任务的执行时间比较短，可以穿插到 JS 任务中间执行，这样就不会因为垃圾回收而感受到页面卡顿了。

