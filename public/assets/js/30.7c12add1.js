(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{510:function(v,_,t){"use strict";t.r(_);var r=t(4),s=Object(r.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h4",{attrs:{id:"https"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[v._v("#")]),v._v(" HTTPS")]),v._v(" "),t("p",[v._v("由于 HTTP 的 ”明文“、”不安全“的缺点，引入了新的 HTTPS 协议来保证通信安全。")]),v._v(" "),t("blockquote",[t("p",[t("strong",[v._v("什么样的通信才算是“安全”的？")])]),v._v(" "),t("ol",[t("li",[v._v("机密性。指对数据保密")]),v._v(" "),t("li",[v._v("完整性。指数据在传输过程中没有被篡改")]),v._v(" "),t("li",[v._v("身份认证。指确认对方的真实身份")]),v._v(" "),t("li",[v._v("不可否认。指不能否认发生的行为。")])])]),v._v(" "),t("p",[v._v("HTTPS 规定了新的协议名 "),t("strong",[v._v("”HTTPS“")]),v._v("，默认端口号 "),t("strong",[v._v("443")]),v._v("，它把 HTTP 下层传输协议替换成了 "),t("strong",[v._v("SSL/TLS协议")]),v._v("。")]),v._v(" "),t("p",[t("strong",[v._v("TLS")]),v._v(" 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。")]),v._v(" "),t("p",[v._v("浏览器和服务器在使用 TLS 建立连接时需要选择一组恰当的加密算法来实现安全通信，这些算法的组合被称为“密码套件”（cipher suite，也叫加密套件）。")]),v._v(" "),t("p",[v._v("密码套件命名格式很固定，基本的形式为：”密钥交换算法 +签名算法 + 对称加密算法 + 摘要算法“")]),v._v(" "),t("blockquote",[t("p",[v._v("例如：ECDHE-RSA-AES256-GCM-SHA384")]),v._v(" "),t("p",[v._v("这个密码套件表示：握手时使用 ECDHE 算法进行密钥交换，用 RSA 算法签名和身份验证，握手后的通信使用 AES256 对称算法，米密钥长度时 256，分组模式是 GCM，摘要算法用 SHA 384用于消息认证和产生随机数")])]),v._v(" "),t("h5",{attrs:{id:"机密性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#机密性"}},[v._v("#")]),v._v(" "),t("strong",[v._v("机密性")])]),v._v(" "),t("p",[v._v("实现机密性常用方法就是 ”加密“。加密前的消息叫做 "),t("strong",[v._v("明文")]),v._v("，加密的钥匙叫做 "),t("strong",[v._v("密钥")]),v._v("，明文加密后的乱码叫做 "),t("strong",[v._v("密文")]),v._v("，使用密钥还原明文叫做 "),t("strong",[v._v("解密")]),v._v("，加密解密的操作过程叫做 ”"),t("strong",[v._v("加密算法")]),v._v("”")]),v._v(" "),t("p",[v._v("加密算法都是公开的，而算法使用的密钥是保密的。根据密钥的使用方式分为 "),t("strong",[v._v("对称加密")]),v._v(" 和 "),t("strong",[v._v("非对称加密")])]),v._v(" "),t("p",[v._v("​\t"),t("strong",[v._v("对称加密")])]),v._v(" "),t("p",[v._v("​\t加密和解密使用的密钥都是同一个密钥。")]),v._v(" "),t("p",[v._v("​\t"),t("strong",[v._v("非对称加密")])]),v._v(" "),t("p",[v._v("​\t对称加密好像实现了机密性。但是如何把密钥安全的传递给对方呢？如果密钥被截获，那么通信也就毫无机密性可言。于是出现了非对称加密。")]),v._v(" "),t("p",[v._v("​\t非对称加密采用了 2 个密钥，一个是 "),t("strong",[v._v("公钥")]),v._v("，另一个是 "),t("strong",[v._v("私钥")]),v._v("。公钥可以公开给任何人知道，而私钥必须严格保密。")]),v._v(" "),t("p",[v._v("​\t公钥和私钥有个特别的单向性："),t("strong",[v._v("公钥加密的密文只能用私钥解密，私钥加密的密文只能用公钥解密")])]),v._v(" "),t("p",[v._v("​\t由于黑客不知道私钥，所以无法知道公钥加密后的密文。")]),v._v(" "),t("p",[t("strong",[v._v("非对称加密")]),v._v(" 加密虽然没有 **”密钥交换“**的问题，但由于加密过程基于复杂的数学运算，运算速度很慢，与对称加密差了好几个量级，如果仅使用非对称加密，虽然实现了机密性，但是通信的速度太慢，实用性太差。")]),v._v(" "),t("p",[t("strong",[v._v("混合加密")])]),v._v(" "),t("p",[v._v("最好的方法是将对称加密和非对称加密结合起来，也就是 "),t("strong",[v._v("混合加密")]),v._v("的方式。")]),v._v(" "),t("p",[v._v("通信开始阶段使用非对称加密，解决密钥交换的问题。使用随机数产生对称算法使用的 "),t("strong",[v._v("”会话密钥“")]),v._v("，再使用公钥加密，对方拿到密文后使用私钥解密得到会话密钥，这样就实现了密钥交换，后续就使用对称加密进行通信。")]),v._v(" "),t("h5",{attrs:{id:"完整性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#完整性"}},[v._v("#")]),v._v(" "),t("strong",[v._v("完整性")])]),v._v(" "),t("p",[t("strong",[v._v("混合加密")]),v._v(" 实现了通信内容机密性，但是黑客可以通过收集足够多的密文，尝试修改，重组后发给网站，应为没有完整性保证，服务器只能照单全收，这样通过服务器的响应获取下一步线索，最后还是会破解出明文。")]),v._v(" "),t("p",[v._v("实现完整性主要靠 "),t("strong",[v._v("摘要算法")]),v._v(" ，也就是常说的 离散函数、哈希函数。")]),v._v(" "),t("p",[v._v("有了 "),t("strong",[v._v("摘要算法")]),v._v("，只要再原文后附上它的摘要就可以保证内容的完整性。但是摘要算法不具有机密性，所以摘要和明文需要一起被加密。")]),v._v(" "),t("p",[t("strong",[v._v("身份认证")])]),v._v(" "),t("p",[v._v("黑客也可以伪装成你向网站发送支付转账等消息，网站没有办法确认你的身份，就会有安全问题。所以需要保证通信双方身份的真实性，现实生活中解决身份认证的手段是签名和印章，只要在纸上签名或者印章，就表示这份文件确实是本人发出的而不是其他人。而这个签名和印章必须是本人持有，独一无二的，只要用这个东西就能证明自己的身份，这个东西就是非对称加密里的 "),t("strong",[v._v("私钥")]),v._v("。")]),v._v(" "),t("p",[v._v("用 "),t("strong",[v._v("私钥")]),v._v(" 加上摘要算法就能实现 ”数字签名“，同时实现身份认证和不可否认。")]),v._v(" "),t("p",[t("strong",[v._v("数字签名")]),v._v("的原理很简单，就是私钥加密，公钥解密。只要你和网站交换了公钥，就能使用 "),t("strong",[v._v("”签名“")]),v._v(" 和 **”验签“**来验证消息的真实性。")]),v._v(" "),t("p",[t("strong",[v._v("数字证书和 CA")])]),v._v(" "),t("p",[v._v("前面所说因为谁都可以发布公钥，公钥的真实性怎么保证呢？也就是怎么证明这是你的或者是网站的公钥？")]),v._v(" "),t("p",[v._v("加入使用类似密钥交换的方式解决公钥认证的问题，那么只会陷入死循环，必须借助一个“外力”，找一个可以信任的第三方作为信任的起点，这个第三方就是 "),t("strong",[v._v("CA（Cerificate Authority，证书认证中心）")]),v._v("。")]),v._v(" "),t("p",[t("strong",[v._v("CA")]),v._v(" 对公钥的签名认证也是有格式的，不能简单将公钥绑定在持有者身份上就完事了，，还要包含序列号，用途，颁发者，有效时间等，把它们打包再签名，形成 "),t("strong",[v._v("数字证书")]),v._v("。")]),v._v(" "),t("p",[v._v("CA 也需要证明自己。小一点的 CA 可以让大 CA 签名认证，到链条的最后也就是 "),t("strong",[v._v("Root CA")]),v._v("，只能自己证明自己，这就是 "),t("strong",[v._v("自签名证书")]),v._v("，你必须相信否则整个证书信任链就走不下去了。")]),v._v(" "),t("p",[v._v("操作系统和浏览器都内置了各大 CA 的根证书，上网的时候只要服务器发过来它的证书，就可以验证证书里的签名，顺着证书链（Certificate Chain）一层层地验证，直到找到根证书，就能够确定证书是可信的，从而里面的公钥也是可信的。")]),v._v(" "),t("h4",{attrs:{id:"https-建立连接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#https-建立连接"}},[v._v("#")]),v._v(" HTTPS 建立连接")]),v._v(" "),t("p",[v._v("HTTP 协议里三次握手建立连接后，就可以发送 HTTP报文；但是 HTTPS 还需要另外一个 ”握手“ 的过程，在 TCP 上建立安全连接后在发送报文。")]),v._v(" "),t("p",[t("strong",[v._v("TLS 1.2 版本")])]),v._v(" "),t("ol",[t("li",[t("p",[t("strong",[v._v("传统RSA连接")])]),v._v(" "),t("p",[v._v("TCP 建立连接后，首先会发送 "),t("strong",[v._v("Client Hello")]),v._v(" 消息，也就是向服务器 “打招呼”。里面有客户端的版本号，支持的密码套件，还有一个 "),t("strong",[v._v("随机数（Client Random）")]),v._v("，用于生成后续会话密钥。")]),v._v(" "),t("p",[v._v("然后服务端回应 "),t("strong",[v._v("Server Hello")]),v._v(" 消息，把版本号确认一下，然后选择一种密码套件（RSA），将服务器生成的一个 "),t("strong",[v._v("随机数（Server Random）")]),v._v("，一并发给对方，然后服务器为了验证自己的身份，将证书也发给了客户端。")]),v._v(" "),t("p",[v._v("之后是 "),t("strong",[v._v("Server Hello Done")]),v._v(" 消息，表示我的消息就这些，”打招呼“完毕。")]),v._v(" "),t("p",[v._v("客户端收到证书后开始走证书链逐级验证，验证服务器身份无误之后，根据密码套件生成 "),t("strong",[v._v("pre-master")]),v._v("，这其实也是一个随机数。客户端发送一个 "),t("strong",[v._v("Client Key Exchange")]),v._v(" 消息， 将pre-master加密后发给服务器。")]),v._v(" "),t("p",[v._v("这样双方都有 3个随机数，通过这三个随机数生成主密钥。主密钥生成后握手就快结束了，客户端会发一个 "),t("strong",[v._v("Change Cipher Spec")]),v._v("，然后再发一个 "),t("strong",[v._v("Finished")]),v._v(" 消息，把之前的数据做一个 "),t("strong",[v._v("摘要")]),v._v("，再加密一下，让服务端做验证。意思是之后通信就用这个密钥加密了，密钥对不对服务器再测一下。")]),v._v(" "),t("p",[v._v("服务器也是同样的操作发送 "),t("strong",[v._v("Change Cipher Spec")]),v._v(" ， "),t("strong",[v._v("Finished")]),v._v(" 消息，双方验证加密解密，后续就使用加密后的 HTTP 请求和响应。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("ECDHE 连接")])]),v._v(" "),t("p",[v._v("之前是传统的 RSA 握手过程，现在主流的TLS 握手过程使用的是 ECDHE 加密套件。")]),v._v(" "),t("p",[v._v("与RSA大致流程相同，不同的是由于使用的 ECDHE 算法，服务器还会生成一个 "),t("strong",[v._v("Server Params")]),v._v(" ，这是 "),t("strong",[v._v("椭圆曲线的公钥")]),v._v("，在发送证书后发送一个 "),t("strong",[v._v("Server Key Exchange")]),v._v(" 消息，里面就是Server Params，用来实现密钥交换算法，再加上自己的私钥签名认证。")]),v._v(" "),t("p",[v._v("然后客户端按照密码套件的要求，也生成一个 "),t("strong",[v._v("Client Params")]),v._v("，用 "),t("strong",[v._v("Client Key Exchange")]),v._v(" 消息发送给服务器。")]),v._v(" "),t("p",[v._v("现在客户端和服务端都拿到了密钥交换算法的两个参数 "),t("strong",[v._v("Server Params")]),v._v(" 和 "),t("strong",[v._v("Client Params")]),v._v("，通过 ECDHE 算法计算生成 "),t("strong",[v._v("pre-master")]),v._v("，用 客户端随机数和服务端随机数加上这个 pre-master，就可以生成主密钥。")]),v._v(" "),t("p",[v._v("主密钥也不是最终通信的会话密钥，还会用PRF算法扩展出更多密钥，比如客户端发送用的会话密钥，服务器发送用的会话密钥等等，避免只用一个密钥带来的安全隐患。")]),v._v(" "),t("p",[v._v("与传统的RSA握手过程有两点不同：")]),v._v(" "),t("ol",[t("li",[v._v("RSA握手 "),t("strong",[v._v("Client Key Change")]),v._v(" 消息里面是 "),t("strong",[v._v("pre-master")]),v._v("；ECDHE 握手则是 "),t("strong",[v._v("密钥交换算法的参数")]),v._v("，pre-master由双方自己计算而来。")]),v._v(" "),t("li",[v._v("ECDHE 算法可以不等服务端发送 "),t("strong",[v._v("Finshed")]),v._v(" 消息确认握手完毕，立即发送 HTTP 报文，节省了一个 消息往返时间的浪费。这个叫 "),t("strong",[v._v('"TLS False Start"')]),v._v("，意思是 ”抢跑“，与 “TCP Fast Open” 有点像，都是不等连接完全建立就提前发送数据。")])])])]),v._v(" "),t("p",[t("strong",[v._v("双向认证")])]),v._v(" "),t("p",[v._v("上面所说的是 "),t("strong",[v._v("单向认证")]),v._v("，只验证了服务器的身份，客户端的身份还没认证。这是因为通常单向认证之后已经建立了安全通信，可以用账号密码等确认客户端的身份。")]),v._v(" "),t("p",[v._v("为了防止账号、密码被盗，有时候比如（网上银行）还会使用 U盾 给客户端颁发证书，"),t("strong",[v._v("实现双向认证")]),v._v("。")]),v._v(" "),t("p",[v._v("双向认证流程没有太多变化，只是再 "),t("strong",[v._v("Server Hello Done")]),v._v(" 之后，"),t("strong",[v._v("Client Key Exchange")]),v._v(" 之前，客户端发送 "),t("strong",[v._v("Client Certificate")]),v._v(" 消息，将自己的证书发给服务器进行验证。")]),v._v(" "),t("p",[t("strong",[v._v("TLS 1.3版本")])]),v._v(" "),t("p",[v._v("TLS1.2 版本已经是十几年前的的老协议，再安全和性能方面已经跟不上现在的互联网了。于是有了 TLS1.3版本。")]),v._v(" "),t("p",[v._v("TLS1.3版本的主要改进目标是 "),t("strong",[v._v("兼容，安全，性能")])]),v._v(" "),t("p",[t("strong",[v._v("兼容")])]),v._v(" "),t("p",[v._v("1.1 1.2版本出现了很多年，许多应用软件，代理商只认识老的记录格式，更新改造困难。为了区分 1.2 和 1.3版本，要用到新的 "),t("strong",[v._v("扩展协议")]),v._v("。通过再记录头的末尾添加一系列扩展字段来增加新的功能。")]),v._v(" "),t("p",[v._v("在记录头的 "),t("strong",[v._v("Version")]),v._v(" 字段被兼容性固定的情况下，只要是 TLS 1.3协议，握手的 "),t("strong",[v._v('"Hello"')]),v._v(" 协议后就必须有 "),t("strong",[v._v('”support_versions"')]),v._v(" 字段，他标记了TLS的版本号。")]),v._v(" "),t("p",[t("strong",[v._v("强化安全")])]),v._v(" "),t("p",[v._v("TLS 1.2 陆续被发现了很多漏洞和加密算法的弱点，因此 TLS1.3 版本修补了这些不安全的因素。")]),v._v(" "),t("p",[v._v("废除了多种算法后，TLS1.3 只保留了 AES, ChaCha20 算法，分组模式只能用 AEAD的 GCM、CCM 和 Poly1305，摘要算法只能使用 SHA256、SHA384，密钥交换算法只有 ECDHE 和 DHE，椭圆曲线也被“砍”到只剩 P-256 和 x25519 等 5 种。")]),v._v(" "),t("blockquote",[t("p",[v._v("这里还要特别说一下废除 RSA 和 DH 密钥交换算法的原因.")]),v._v(" "),t("p",[v._v("假设有这么一个很有耐心的黑客，一直在长期收集混合加密系统收发的所有报文。如果加密系统使用服务器证书里的 RSA 做密钥交换，一旦私钥泄露或被破解（使用社会工程学或者巨型计算机），那么黑客就能够使用私钥解密出之前所有报文的“Pre-Master”，再算出会话密钥，破解所有密文。")]),v._v(" "),t("p",[v._v("而 ECDHE 算法在每次握手时都会生成一对临时的公钥和私钥，每次通信的密钥对都是不同的，也就是“一次一密”，即使黑客花大力气破解了这一次的会话密钥，也只是这次通信被攻击，之前的历史消息不会受到影响，仍然是安全的。")]),v._v(" "),t("p",[v._v("以现在主流的服务器和浏览器在握手阶段都已经不再使用 RSA，改用 ECDHE，而 TLS1.3 在协议里明确废除 RSA 和 DH 则在标准层面保证了“前向安全”")])]),v._v(" "),t("p",[t("strong",[v._v("提升性能")])]),v._v(" "),t("p",[v._v("HTTPS 建立连接时需要再进行 TLS 握手，再 1.2版本中会多花 2 个RTT的消息往返时间，可能会导致几十甚至几百毫秒的延迟，在移动网络中延迟还会更严重。")]),v._v(" "),t("p",[v._v("TLS 1.3 密码套件大幅简化后，就不必再向以前那样走复杂的流程了。TLS1.3 压缩了以前的“Hello”协商过程，删除了“Key Exchange”消息，把握手时间减少到了“1-RTT”，效率提高了一倍。")]),v._v(" "),t("p",[v._v("具体的做法还是利用了扩展。客户端在“Client Hello”消息里直接用“"),t("strong",[v._v("supported_groups")]),v._v("”带上支持的曲线，比如 P-256、x25519，用 “"),t("strong",[v._v("key_share")]),v._v("” 带上曲线对应的客户端公钥参数，用“"),t("strong",[v._v("signature_algorithms")]),v._v("”带上签名算法。")]),v._v(" "),t("p",[v._v("服务器收到后在这些扩展里选定一个曲线和参数，再用 "),t("strong",[v._v("“key_share”")]),v._v(" 扩展返回服务器这边的公钥参数，就实现了双方的密钥交换，后面的流程就和 1.2 基本一样了")]),v._v(" "),t("h4",{attrs:{id:"https-性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#https-性能优化"}},[v._v("#")]),v._v(" HTTPS 性能优化")]),v._v(" "),t("p",[v._v('HTTPS 连接”慢“通常指的时刚开始建立连接那段时间。除了TLS 握手带来的网络耗时外，产生密钥交换的临时公私钥对（ECDHE）、验证证书、非对称加密处理 “pre-master"')]),v._v(" "),t("p",[v._v("那有哪些手段可以进行优化呢？")]),v._v(" "),t("p",[t("strong",[v._v("硬件优化")])]),v._v(" "),t("ol",[t("li",[t("p",[v._v("更快的 CPU")])]),v._v(" "),t("li",[t("p",[v._v("SSL加速卡：加解密时调用它的API，让专门的硬件来做非对称加密，分担 CPU 的计算压力。但是也有缺点：升级慢，支持算法有限，不能灵活制定解决方案")])]),v._v(" "),t("li",[t("p",[v._v("SSL加速服务器：用专门的服务器集群来彻底“卸载”TLS 握手时的加密解密计算，性能自然要比单纯的“加速卡”要强大的多。")])])]),v._v(" "),t("p",[t("strong",[v._v("软件优化")])]),v._v(" "),t("p",[v._v("软件优化比较简单，就是尽量将正在使用的软件升级到最新版本，由于软件在更新版本的时候都会做性能优化、修复错误，因此优化效果最容易达到。")]),v._v(" "),t("p",[t("strong",[v._v("协议优化")])]),v._v(" "),t("p",[v._v("尽量采用 TLS1.3 版本，它大幅简化了握手过程，相比TLS1.2 少了 1 RTT，而且更加安全。")]),v._v(" "),t("p",[t("strong",[v._v("会话复用")])]),v._v(" "),t("p",[v._v("会话复用分两种：")]),v._v(" "),t("p",[v._v("一种叫 "),t("strong",[v._v("”Session ID“")]),v._v("：就是客户端和服务器首次连接后各自保存一个会话的 ID 号，内存里存储主密钥和其他相关的信息。当客户端再次连接时发一个 ID 过来，服务器就在内存里找，找到就直接用主密钥恢复会话状态，跳过证书验证和密钥交换，只用一个消息往返就可以建立安全通信。")]),v._v(" "),t("p",[v._v("另一种叫 "),t("strong",[v._v('"Session Ticket"')]),v._v(": 它有点类似 HTTP 的 Cookie，存储的责任由服务器转移到了客户端，服务器加密会话信息，用“New Session Ticket”消息发给客户端，让客户端保存。")]),v._v(" "),t("p",[v._v("重连的时候，客户端使用扩展“"),t("strong",[v._v("session_ticket")]),v._v("”发送“Ticket”而不是“Session ID”，服务器解密后验证有效期，就可以恢复会话，开始加密通信。不过“Session Ticket”方案需要使用一个固定的密钥文件（ticket_key）来加密 Ticket，为了防止密钥被破解，保证“前向安全”，密钥文件需要定期轮换，比如设置为一小时或者一天。")]),v._v(" "),t("p",[t("strong",[v._v("预共享密钥")])]),v._v(" "),t("p",[v._v("原理和“Session Ticket”差不多，但在发送 Ticket 的同时会带上应用数据（Early Data），免去了 1.2 里的服务器确认步骤，这种方式叫“"),t("strong",[v._v("Pre-shared Key")]),v._v("”，简称为“PSK”。")]),v._v(" "),t("p",[v._v("但“PSK”也不是完美的，它为了追求效率而牺牲了一点安全性，容易受到“重放攻击”（Replay attack）的威胁。黑客可以截获“PSK”的数据，像复读机那样反复向服务器发送。")]),v._v(" "),t("p",[v._v("解决的办法是只允许安全的 GET/HEAD 方法，在消息里加入时间戳、“nonce”验证，或者“一次性票证”限制重放。")]),v._v(" "),t("blockquote",[t("p",[v._v('"Session ID" 和 "Session Ticket" 这两种会话复用的方式在 TLS1.3中均已经被废除了，只能使用 PSK 实现会话复用')])])])}),[],!1,null,null,null);_.default=s.exports}}]);