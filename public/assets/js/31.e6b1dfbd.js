(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{510:function(s,n,a){"use strict";a.r(n);var t=a(4),e=Object(t.a)({},(function(){var s=this,n=s.$createElement,a=s._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h4",{attrs:{id:"如何理解作用域和作用域链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何理解作用域和作用域链"}},[s._v("#")]),s._v(" 如何理解作用域和作用域链")]),s._v(" "),a("p",[a("strong",[s._v("什么是作用域")])]),s._v(" "),a("p",[s._v("作用域简单来说就是 "),a("strong",[s._v("程序中定义变量的位置，这个位置决定了变量的生命周期。通俗的来说，作用域就是变量和函数的可访问范围")])]),s._v(" "),a("p",[s._v("ES6 之前只有两种作用域：")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("全局作用域")]),s._v("：全局作用域中的变量在任何地方都可访问，其生命周期伴随页面的生命周期")]),s._v(" "),a("li",[a("strong",[s._v("函数作用域")]),s._v("：函数作用域就是在函数的代码区域，函数作用域中的变量和函数只能在内部进行访问，函数执行完后就会被销毁。")])]),s._v(" "),a("p",[s._v("ES6 "),a("strong",[s._v("新增了块级作用域")]),s._v("。 块级作用域就是使用大括号括起来的代码区域。例如 函数、循环语句、判断语句或者单独的 {} 也看作是块级作用域。")]),s._v(" "),a("p",[a("strong",[s._v("为什么新增块级作用域")])]),s._v(" "),a("p",[s._v("原来 ES6 之前变量可以在声明之前访问，值是 undefined，也就是变量提升。")]),s._v(" "),a("p",[s._v("变量提升带来的问题有：")]),s._v(" "),a("ol",[a("li",[s._v("变量容易在不被察觉的情况下被覆盖掉")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("var name = 'jack'\nfunction a () {\n\tconsole.log(name)\n\tif (0) {\n\t\tvar name = 'mark'\n\t}\n\tconsole.log(name)\n}\na()\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("p",[s._v("这段代码输出的是 undefined，原因是 if 代码块内声明的变量被提升，值的是undefined")]),s._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[s._v("本应销毁的变量没有被销毁")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("let a = 'jack'\nfor (var i = 0; i < 2; i++) {\n\tconsole.log(a[i])\n}\nconsole.log(i)\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("i 仍然存在")]),s._v(" "),a("p",[s._v("ES6 通过 "),a("strong",[s._v("let、const")]),s._v(" 实现了块级作用域")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function test () {\n\tlet a = 'mark'\n\tif (true) {\n\t\tlet a = 'jack'\n\t}\n\tconsole.log(a) // mark\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("p",[a("strong",[s._v("作用域链")])]),s._v(" "),a("p",[s._v("函数执行上下文中包含有外部环境的引用"),a("strong",[s._v("outer")]),s._v("，JS 引擎查找变量的时候先在当前执行上下文中查找，如果没有找到就会到outer指向的执行上下文中去查找，一直查找到全局执行上下文，这样一条查找链就是作用域链。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function foo () {\n\tconsole.log(name)\n}\nfunction bar () {\n\tlet name = 'jack'\n\tfoo()\n}\nlet name = 'mark'\nbar() // 输出mark\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("p",[s._v("输出的是 mark ，原因是 foo 的外部引用outer指向是全局执行上下文，"),a("strong",[s._v("这是由词法作用域决定的")])]),s._v(" "),a("h4",{attrs:{id:"闭包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[s._v("#")]),s._v(" "),a("strong",[s._v("闭包")])]),s._v(" "),a("p",[a("strong",[s._v("什么是闭包")])]),s._v(" "),a("blockquote",[a("p",[s._v("闭包是指有权访问另一个函数作用域中变量的函数")])]),s._v(" "),a("p",[a("strong",[s._v("根据词法作用域的规则，内部作用域总是可以访问外部作用域中的变量，当通过外部函数返回内部函数后，即时外部函数执行结束了，内部函数引用的外部函数中的变量仍然保存在内存中，这就产生了闭包")]),s._v("。")]),s._v(" "),a("p",[s._v("本质上就是当前环境持有指向父级作用域的引用。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function foo () {\n\tlet num = 1\n\treturn function () {\n\t\tnum = num+1\n\t\treturn num\n\t}\n}\nlet f = foo()\nf() // 2\nf() // 3\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("p",[a("strong",[s._v("闭包的缺点")]),s._v(" ：如果引用闭包的函数是一个全局变量，那么闭包会一直存在内存中直到页面关闭；如果这个闭包不在使用的话就会造成内存泄漏。因此如果该闭包使用频率不高，内存比较大的话，尽量让它成为一个局部变量，函数执行完后会自动销毁，被垃圾回收器回收。")])])}),[],!1,null,null,null);n.default=e.exports}}]);