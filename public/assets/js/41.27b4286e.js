(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{522:function(v,_,t){"use strict";t.r(_);var T=t(4),r=Object(T.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h4",{attrs:{id:"http-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-2"}},[v._v("#")]),v._v(" HTTP 2")]),v._v(" "),t("p",[v._v("HTTPS 在安全方面已经做的非常好了，HTTP 2 主要对性能做了很大改进。")]),v._v(" "),t("p",[t("strong",[v._v("头部压缩")])]),v._v(" "),t("p",[v._v("首先是对报文头部进行了改动。")]),v._v(" "),t("p",[v._v('原先HTTP报文头部经常会携带 ”User Agent" 、"cookie" 、“Server"、”Accept“ 等固定的头字段，多达几百甚至上千字节，而 body 部分却经常只有几十字节，就像一个 ”大头儿子“。而且成千上万个请求报文里头部字段有很多字段都是重复的，非常浪费。')]),v._v(" "),t("p",[v._v("于是 HTTP 2 中对头部进行了压缩，没有采用传统的压缩算法，而是开发了专门的 "),t("strong",[v._v("HPACK")]),v._v(" 算法。在客户端和服务器两端建立 ”字典“，")]),v._v(" "),t("p",[v._v("用索引号代替重复的字符串，还采用了 哈夫曼编码 来压缩整数和字符串,，可以达到 50% - 90%的压缩率。")]),v._v(" "),t("p",[v._v("HPACK 算法 是专门为压缩 HTTP 头部而制定的算法。它需要客户端和服务端各自维护一份索引表，为了方便管理和压缩，废除了起始行的概念，把起始行中的请求方法，URI，状态码转换成了头字段的形式，并给这些不是头字段的头字段起了一个名字——"),t("strong",[v._v("”伪头字段“")]),v._v('。为了和真实的头字段区分开来，这些 ”伪头字段" 会在名字的前面加一个 “：”,比如 ":authority"、“:method"、”:status" 分别表示域名，方法名，状态码。')]),v._v(" "),t("p",[v._v('这样 HTTP 报文头全是 "key-value"形式的字段，于是 HTTP2 为这些常用的头字段定义了一个只读的 '),t("strong",[v._v("”静态表“")]),v._v("。")]),v._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"C:\\Users\\李东旭\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210126140401129.png",alt:"image-20210126140401129"}}),v._v(" "),t("p",[v._v("数字 2 表示 GET, 数字 8 表示状态码200。")]),v._v(" "),t("p",[v._v("如果表里只有 Key 没有 Value，或者是自定义字段找不到怎么办？")]),v._v(" "),t("p",[v._v("这就需要用到 "),t("strong",[v._v("”动态表“")]),v._v("，它添在静态表的后面，结构相同，但是会在编码解码的时候随时更新。")]),v._v(" "),t("p",[v._v("比如说，第一次发送请求时的“user-agent”字段长是一百多个字节，用哈夫曼压缩编码发送之后，客户端和服务器都更新自己的动态表，添加一个新的索引号“65”。那么下一次发送的时候就不用再重复发那么多字节了，只要用一个字节发送编号就好。")]),v._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"C:\\Users\\李东旭\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210126141141813.png",alt:"image-20210126141141813"}}),v._v(" "),t("p",[t("strong",[v._v("二进制格式")])]),v._v(" "),t("p",[v._v("HTTP2 中不在使用 ASCII 码，而是向底层 TCP/IP 协议靠拢，"),t("strong",[v._v("使用二进制格式")]),v._v("。")]),v._v(" "),t("p",[v._v("HTTP2 把原来”head+body“形式的报文分成了一个个二进制帧，"),t("strong",[v._v('"HEADERS" 帧')]),v._v("存放头数据，"),t("strong",[v._v('”DATA"帧')]),v._v(" 存放实体数据。")]),v._v(" "),t("p",[v._v("HTTP2 的帧结构如下：")]),v._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"C:\\Users\\李东旭\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210126142532818.png",alt:"image-20210126142532818"}}),v._v(" "),t("p",[t("strong",[v._v("长度")]),v._v(" 是3 字节，默认上限是 2^14，最大是 2^24，也就是说帧长度通常不超过 16k，最大为 16M")]),v._v(" "),t("p",[t("strong",[v._v("帧类型")]),v._v(" 分为 "),t("strong",[v._v("数据帧")]),v._v(" 和 "),t("strong",[v._v("控制帧")]),v._v("，HEADERS 帧和 DATA 帧是数据帧，存放的是 HTTP报文；SETTINGS、PING、PRIORITY 是控制帧，用来管理流。")]),v._v(" "),t("p",[t("strong",[v._v("帧标志")]),v._v("：可以保存 8 个标志位，携带简单的控制信息。常用的标志位有 "),t("strong",[v._v("END_HEADERS")]),v._v(' 表示头数据结束，相当于 HTTP/1 的空行 "\\r\\n",')]),v._v(" "),t("p",[t("strong",[v._v("END_STREAM")]),v._v("表示单方向数据发送结束（即 EOS，End of Stream），相当于 HTTP/1 里 Chunked 分块结束标志（“0\\r\\n\\r\\n”）。")]),v._v(" "),t("p",[t("strong",[v._v("流标识符")]),v._v(" ：也就是帧所属的“流”，接收方使用它就可以从乱序的帧里识别出具有相同流 ID 的帧序列，按顺序组装起来就实现了虚拟的“流”")]),v._v(" "),t("p",[t("strong",[v._v("多路复用")])]),v._v(" "),t("p",[v._v("HTTP2 里面的 **“流”**其实就是二进制帧的双向传输序列。")]),v._v(" "),t("p",[v._v("HTTP2 可以在一个TCP上用 ”流“ 同时发送多个消息，也就是 "),t("strong",[v._v("多路复用")]),v._v("。虽然帧是乱序发的，但是只要它们具有同一个流ID，在这个流里面帧不是无序的，而是有着严格的先后顺序。")]),v._v(" "),t("p",[v._v("HTTP2 流的特点：")]),v._v(" "),t("ol",[t("li",[v._v("流是可并发的。意思是一个TCP连接上可以同时发出多个流传输数据，也就是同时发送多个请求，实现多路复用")]),v._v(" "),t("li",[v._v("客户端和服务端都可以创建流，双方互不干扰")]),v._v(" "),t("li",[v._v("流是双向的，一个流里面客户端和服务端都可以发送和接收数据，也就是一个请求-应答来回")]),v._v(" "),t("li",[v._v("流之间没有固定关系，彼此独立，但是流内部帧有严格的顺序")]),v._v(" "),t("li",[v._v("流可以设置优先级，让服务器优先处理。比如先传 HTML/CSS，后传图片")]),v._v(" "),t("li",[v._v("流ID 不能重用，只能顺序递增，客户端发起的 ID 是奇数，服务器端发起的 ID 是偶数；如果流ID 用完了，可以发一个控制帧 "),t("strong",[v._v('"GOAWAY"')]),v._v("，真正关闭TCP连接")]),v._v(" "),t("li",[v._v("在流上发送“RST_STREAM”帧可以随时终止流，取消接收或发送；")]),v._v(" "),t("li",[v._v("第 0 号流比较特殊，不能关闭，也不能发送数据帧，只能发送控制帧，用于流量控制。")])]),v._v(" "),t("p",[t("strong",[v._v("Server Push")])]),v._v(" "),t("p",[v._v("前面说过流双方都可以创建，服务器不再是被动地接收请求，响应请求，它也可以创建流把数据发给客户端。")]),v._v(" "),t("p",[v._v("比如提前给客户端推送一些必要的资源，就可以相对减少一点延迟时间。服务器主动推送，客户端有权利决定是否接收。另外 主动推送也遵守同源策略。")]),v._v(" "),t("h4",{attrs:{id:"http-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-3"}},[v._v("#")]),v._v(" HTTP 3")]),v._v(" "),t("p",[v._v("HTTP2 虽然解决了很多旧版本的问题，但是还有一个巨大的问题，主要是由底层 TCP 协议造成的。")]),v._v(" "),t("p",[v._v("HTTP2 的多路复用可以实现多个请求的并发，没有”队头阻塞“，但实际上在底层的 TCP 协议中，还是会发生队头阻塞。如果网络比较差，出现了丢包的情况，那么整条 TCP 连接需要等待重传，其他数据包虽然收到了但是也必须等待丢失的包确认，这样就发生了对头阻塞。而且由于所有请求都在一条 TCP 连接上，在网络差的情况下的表现反倒不如 HTTP1.1。")]),v._v(" "),t("p",[v._v("因此 HTTP3 使用了一个新的协议 "),t("strong",[v._v("QUIC")])]),v._v(" "),t("p",[t("strong",[v._v("QUIC")])]),v._v(" "),t("p",[v._v("QUIC 协议选用了 UDP 协议，并且在它之上把 TCP 的那一套连接管理、拥塞窗口、流量控制等“搬”了过来，“去其糟粕，取其精华”。")]),v._v(" "),t("p",[v._v("QUIC 特点:")]),v._v(" "),t("p",[v._v("QUIC 基于 UDP，而 UDP 是“无连接”的，根本就不需要“握手”和“挥手”，所以天生就要比 TCP 快。")]),v._v(" "),t("p",[v._v("就像 TCP 在 IP 的基础上实现了可靠传输一样，QUIC 也基于 UDP 实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似 HTTP/2 的“流”和“多路复用”，单个“流”是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。")]),v._v(" "),t("p",[v._v("为了防止网络上的中间设备（Middle Box）识别协议的细节，QUIC 全面采用加密通信，可以很好地抵御窜改和“协议僵化”（ossification）。")]),v._v(" "),t("p",[v._v("而且，因为 TLS1.3 已经在去年（2018）正式发布，所以 QUIC 就直接应用了 TLS1.3，顺便也就获得了 0-RTT、1-RTT 连接的好处。")]),v._v(" "),t("p",[v._v("但 QUIC 并不是建立在 TLS 之上，而是内部“包含”了 TLS。它使用自己的帧“接管”了 TLS 里的“记录”，握手消息、警报消息都不使用 TLS 记录，直接封装成 QUIC 的帧发送，省掉了一次开销。")])])}),[],!1,null,null,null);_.default=r.exports}}]);