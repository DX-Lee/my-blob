(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{515:function(v,t,_){"use strict";_.r(t);var e=_(4),o=Object(e.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h4",{attrs:{id:"eventloop"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#eventloop"}},[v._v("#")]),v._v(" EventLoop")]),v._v(" "),_("p",[v._v("由于 JavaScript  是"),_("strong",[v._v("单线程")]),v._v("，单线程就意味着所有任务都得排队执行，只有前面的任务执行完，才会执行后一个任务，像网络请求这些任务耗时很长，后面的任务就不得不等待，导致页面卡顿，无响应。")]),v._v(" "),_("p",[v._v("为了解决这种问题，JavaScript 里将任务分成了"),_("strong",[v._v("同步任务")]),v._v("和"),_("strong",[v._v("异步任务")]),v._v("。")]),v._v(" "),_("p",[_("strong",[v._v("同步任务")]),v._v("：即按顺序执行的任务，只有前面一个任务执行完才执行后一个任务")]),v._v(" "),_("p",[_("strong",[v._v("异步任务")]),v._v("：先挂起，等待结果返回就放到任务队列中，等待读取。")]),v._v(" "),_("p",[v._v("任务队列是一个符合 ”先进先出“ 特点的队列，就也是放任务从队尾放，取任务从队头取。当执行栈为空的时候，JavaScript 就会到任务队列中读取任务，把它放到执行栈中去执行，这个过程是循环不断的，这样的运行机制就称为事件循环。")]),v._v(" "),_("p",[_("strong",[v._v("宏任务和微任务")])]),v._v(" "),_("p",[v._v("任务队列中的任务属于 "),_("strong",[v._v("宏任务")]),v._v("，每一个宏任务内部都包含一个 "),_("strong",[v._v("微任务队列")]),v._v("。"),_("strong",[v._v("当宏任务执行结束之前，都会去检查微任务队列，如果有，就会去执行微任务队列中的任务，并将其清空。")])]),v._v(" "),_("blockquote",[_("p",[v._v("为什么要引入微任务？")]),v._v(" "),_("p",[v._v("其实就是异步回调的执行时机问题。异步回调的处理方式无非就是两种：")]),v._v(" "),_("ol",[_("li",[v._v("放到宏任务队列队尾处理")]),v._v(" "),_("li",[v._v("放到当前宏任务末尾执行。")])]),v._v(" "),_("p",[v._v("两者区别在于如果使用第一种方式，当当前任务队列任务非常长，那么这个异步回调会迟迟都不到执行，如果使用第二种，执行时机就大大提前了，实时性会更好。")])]),v._v(" "),_("p",[v._v("微任务有：promise.then/catch/finally 、MutationOberver，Process.nextTick() (Node独有)")]),v._v(" "),_("p",[v._v("宏任务有：setTimeout，setInterval，I/O等")])])}),[],!1,null,null,null);t.default=o.exports}}]);