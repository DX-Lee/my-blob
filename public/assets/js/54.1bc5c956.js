(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{533:function(v,e,t){"use strict";t.r(e);var T=t(4),_=Object(T.a)({},(function(){var v=this,e=v.$createElement,t=v._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[t("strong",[v._v("TCP RST包")])]),v._v(" "),t("p",[v._v("在 TCP 协议中 RST 表示复位，用来"),t("strong",[v._v("异常的")]),v._v("关闭连接，发送 RST 关闭连接时，不必等缓冲区的数据都发送出去，直接丢弃缓冲区中的数据，连接释放进入"),t("code",[v._v("CLOSED")]),v._v("状态。而接收端收到 RST 段后，也不需要发送 ACK 确认。")]),v._v(" "),t("p",[t("strong",[v._v("RST 出现的原因")])]),v._v(" "),t("ul",[t("li",[t("p",[v._v("端口未监听")]),v._v(" "),t("p",[v._v("这种情况比较常见，当 web 服务器未启动或者挂掉的时候，客户端使用 connect 重连就会出现")])]),v._v(" "),t("li",[t("p",[v._v("连接信息丢失而另一方并不知情")]),v._v(" "),t("p",[v._v("如果服务器突然断电重启，之前主机上的所有 TCP 连接都丢失了，但是客户端完全不知道这个情况，但客户端继续发送数据给服务端时，服务端没有这条连接的信息，直接返回 RST 包，告知客户端无法处理。")])]),v._v(" "),t("li",[t("p",[v._v("调用 close 函数，设置了 SO_LINGER 为 true")]),v._v(" "),t("p",[v._v("如果设置 SO_LINGER 为 true，linger 设置为 0，当调用 socket.close() 时， close 函数会立即返回，同时丢弃缓冲区内所有数据并立即发送 RST 包重置连接")])])]),v._v(" "),t("blockquote",[t("p",[v._v("RST 包丢失了怎么办？")]),v._v(" "),t("p",[v._v("RST 包是不需要确认的。")]),v._v(" "),t("p",[v._v("在 RST 包没有丢失的情况下，服务端发送 RST 后马上释放连接，进入 CLOSED 状态，客户端收到 RST 包后也立刻释放连接，进入 CLOSED 状态。")]),v._v(" "),t("p",[v._v("当 RST 包丢失了，客户端是不知情的，只会认为数据包丢失了会尝试重传，收到 RST 包后释放连接进入 CLOSED 状态，如果 RST 包依旧丢失，会继续重传一定次数后放弃。")])]),v._v(" "),t("p",[t("strong",[v._v("超时重传")])]),v._v(" "),t("p",[v._v("正常发送数据包对端收到后会回复 ACK 包，如果给定时间内未收到会进行重传，重传的时间间隔为 2 的指数级退避，重传的次数tcp_retries 的值决定，会根据 RTO 动态变化。")]),v._v(" "),t("p",[v._v("如果发送 5000 个字节的数据包，因为 MSS 的限制每次传输 1000 个字节，分 5 段传输，如下图")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/2/27/1692f8781978ccc9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"img"}})]),v._v(" "),t("p",[v._v("数据包 1 发送的数据正常到达接收端，接收端回复 ACK 1001，表示 seq 为1001之前的数据包都已经收到，下次从1001开始发。 数据包 2（10001：2001）因为某些原因未能到达服务端，其他包正常到达，这时接收端也不能 ack 3 4 5 数据包，因为数据包 2 还没收到，接收端只能回复 ack 1001。")]),v._v(" "),t("p",[v._v("第 2 个数据包重传成功以后服务器会回复5001，表示seq 为 5001 之前的数据包都已经收到了。")]),v._v(" "),t("p",[v._v("由于重传的时间间隔要等几百毫秒才会进行第一次重传，于是有了 "),t("strong",[v._v("快速重传")]),v._v("：快速重传的含义就是当发送端收到3个或以上的重复的 ACK 后，就意识到之前发的包可能丢了，于是马上重传，不用等超时才重传。")]),v._v(" "),t("p",[v._v("但是这里有个问题：快速重传只能知道需要重传，但是不知道哪个包需要重传，因为发送 3，4，5号包收到的 ack 都是 1001, 除了2号包可能丢失，3，4，5号包也可能丢失。")]),v._v(" "),t("p",[v._v("所以 "),t("strong",[v._v("SACK")]),v._v(" （Selective Acknowledgement）就派上用场。")]),v._v(" "),t("ul",[t("li",[v._v("在收到3包的 ACK 包中告诉发送端 当前收到的最大包序列号是 1000 （ack=1001）, [1,1001]、[2001,3001]区间内的包也收到了")]),v._v(" "),t("li",[v._v("在收到4包的 ACK 包中告诉发送端 当前收到的最大包序列号是 1000 （ack=1001）, [1,1001]、[2001,4001]区间内的包也收到了")]),v._v(" "),t("li",[v._v("在收到5包的 ACK 包中告诉发送端 当前收到的最大包序列号是 1000 （ack=1001）, [1,1001]、[2001,5001]区间内的包也收到了")])]),v._v(" "),t("p",[v._v("这样发送端就知道 2 号包丢了，只需要传2号包就可以了。")]),v._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://user-gold-cdn.xitu.io/2019/2/27/1692f878596b44a2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"img"}}),v._v(" "),t("p",[t("strong",[v._v("重传间隔")])]),v._v(" "),t("p",[t("strong",[v._v("RTO(Retransmission TimeOut)")]),v._v(" 超时重传时间，这个时间不是一成不变的，它会随着不同的网络情况动态进行调整，它与 RTT (Round-trip Time) 密切相关。下面是几种计算 RTO 的方法")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("经典方法")]),v._v(" （适用于 RTT 波动较小的情况）")]),v._v(" "),t("p",[v._v("经典算法引入了 "),t("strong",[v._v("平滑往返时间 SRTT (Smoothed round trip time)")]),v._v(" 的概念: 经过平滑后的 RTT 的值，每测量一次 RTT 就对 SRTT 作一次更新。")]),v._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("SRTT = ( α * SRTT ) + ((1- α) * RTT)\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br")])]),t("p",[v._v("α 是平滑因子，建议值是0.8 ~ 0.9。假设平滑因子 α = 0.8，那么 SRTT = 80% 的原始值 + 20% 的新采样值。相当于一个低通滤波器")]),v._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://user-gold-cdn.xitu.io/2019/4/5/169ee07ddc1eb50a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"img"}}),v._v(" "),t("p",[v._v("当 α 趋向于 1，1 - α 趋向于0，SRTT 就趋向于上一次 SRTT 的值，与新的 RTT 关系就越小，表现出来的就是对短暂的时延变化不敏感")]),v._v(" "),t("p",[v._v("当 α 趋向于 0，1 - α 趋向于1，SRTT 就趋向于新采样的 RTT 的值，与旧的 SRTT 关系就越小，表现出来的就是对短暂的时延变化更加敏感，更够快速的跟随时延的变化而变化")]),v._v(" "),t("p",[v._v("重传时间 RTO 的公式是")]),v._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("RTO = min(ubound, max(lbound, β * SRTT))\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br")])]),t("p",[v._v("β 为加权因子，一般推荐值为 1.3~2.0 ，ubound 为 RTO 的上边界，lbound 为 RTO 的下边界，公示的含义其实就是 RTO 是 一个 1.3 到 2.0 倍的 SRTT 值，最大不超过 ubound, 最小不低于 lbound。")]),v._v(" "),t("p",[v._v("这个算法下 平滑因子 α 取值范围是 0.8 ~ 0.9 ，RTT 的变化对 RTO 影响太小了，在相对稳定的网络中这个算法表现还算可以，但是在一个 RTT 变化较大的环境中效果就比较差。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("标准算法")])]),v._v(" "),t("p",[v._v("传统方法最大的问题是RTT 有大的波动时，很难即时反应到 RTO 上，因为都被平滑掉了。标准方法对 RTT 的采样增加了一个新的因素")]),v._v(" "),t("p",[v._v("公式如下")]),v._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("SRTT = (1 -  α) * SRTT +  α * RTT\nRTTVAR = (1 - β) * RTTVAR + β * (|RTT-SRTT|) \nRTO= µ * SRTT + ∂ * RTTVar\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br"),t("span",{staticClass:"line-number"},[v._v("2")]),t("br"),t("span",{staticClass:"line-number"},[v._v("3")]),t("br")])]),t("p",[v._v("先看第一个公式：")]),v._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("SRTT = (1 -  α) * SRTT +  α * RTT\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br")])]),t("p",[v._v("和经典算法一样的，区别是，α 的建议值是 0.125，这种情况下 SRTT = 87.5%的原始值 + 12.5%的新采样值")]),v._v(" "),t("p",[v._v("第二个公式：计算 "),t("strong",[v._v("RTTVAR")]),v._v("：「已平滑的 RTT 平均偏差估计器」（round-trip time variation，RTTVAR）")]),v._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("RTTVAR = (1 - β) * RTTVAR + β * (|RTT-SRTT|) \n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br")])]),t("p",[v._v("平均偏差是标准方差的良好近似，计算较为容易，无需标准方差的求平方根运算。如果 β 取建议值 0.25 则 RTTVAR = 75%的原始值 + 25%的 平滑 SRTT 与 最新测量 RTT 的差值")]),v._v(" "),t("p",[v._v("第三个公式计算最终的 RTO：")]),v._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("RTO= µ * SRTT + ∂ * RTTVar\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br")])]),t("p",[v._v("μ 建议取 1，∂ 建议值取 4，则 RTO = SRTT + 4 RTTVAR")]),v._v(" "),t("p",[v._v("这种算法下 "),t("strong",[v._v("RTO 与 RTT 变化的差值关系更密切，能对变化剧烈的 RTT做出更及时的调整。")])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("重传二义性和 Karn / Partridge 算法")])]),v._v(" "),t("p",[v._v("前面的方法没有解决对于重传的情况下如何计算 RTT （时间戳可以解决）")]),v._v(" "),t("ul",[t("li",[v._v("既然不能确定 ACK 包到底对应重传包还是非重传包，那这次就忽略吧，这次重传的 RTT 不会被用来更新 SRTT 及后面的 RTO")]),v._v(" "),t("li",[v._v("只有当收到未重传过的某个请求的 ACK 包时，才更新 SRTT 等变量并重新计算RTO")])]),v._v(" "),t("p",[v._v("仅仅有上面的规则是远远不够的，放弃掉重传那次不管看起来就像遇到危险把头埋在沙子里的鸵鸟。如果网络抖动，倒是突然出现大量重传，但这个时候 RTO 没有更新，就很坑了，本身 RTO 就是为了自适应网络延迟状况的，结果出问题了没有任何反应。这里 Karn 算法采用了出现重传就将 RTO 翻倍的方法，这就是我们前面看到过的指数级退避（Exponential backoff）。这种方式比较粗暴，但是非常简单。")])])]),v._v(" "),t("p",[t("strong",[v._v("总结")])]),v._v(" "),t("p",[v._v("​\tRST出现的原因：")]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[v._v("\t1. 端口未监听\n\t2. 连接丢失而另一端并不知情继续发送数据\n\t3. SO_LINGER 设置丢弃缓冲区数据，立刻 RST\n")])])]),t("p",[v._v("快速重传 ACK")]),v._v(" "),t("p",[v._v("计算重传间隔的算法：")]),v._v(" "),t("p",[v._v("​\t1. 经典算法：适用于 RTT 波动较小的情况下")]),v._v(" "),t("p",[v._v("​\t2. 标准算法：在 RTT 波动较大的情况下有更好的适应效果。")])])}),[],!1,null,null,null);e.default=_.exports}}]);