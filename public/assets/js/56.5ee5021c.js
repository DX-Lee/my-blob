(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{536:function(v,_,t){"use strict";t.r(_);var s=t(4),r=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[v._v("前面介绍了 TCP 用滑动窗口来做流量控制，可以防止发送端向接收端发送过多的数据。但这只考虑了发送端和接收端自身的情况，没有考虑整个网络通信的问题。当网络状况比较差的时候，TCP 需要进行拥塞处理。")]),v._v(" "),t("p",[v._v("拥塞处理主要涉及了下面几个算法")]),v._v(" "),t("ul",[t("li",[v._v("慢启动")]),v._v(" "),t("li",[v._v("拥塞避免")]),v._v(" "),t("li",[v._v("快速重传和快速恢复")])]),v._v(" "),t("p",[v._v("为了实现上面的算法，每个 TCP 连接都需要有两个核心状态值：")]),v._v(" "),t("ul",[t("li",[v._v("拥塞窗口 （cwnd）")]),v._v(" "),t("li",[v._v("慢启动阈值 (ssthresh)")])]),v._v(" "),t("p",[t("strong",[v._v("拥塞窗口")]),v._v("（Congestion Window, cwnd）")]),v._v(" "),t("p",[v._v("拥塞窗口指的是在收到对端 ACK 之前自己还能传输的最大MSS 段数")]),v._v(" "),t("p",[v._v("它与前面 接收窗口 （rwnd）有什么关系呢？")]),v._v(" "),t("ul",[t("li",[v._v("接收窗口 是接收端的限制，表示接收端还能接收的数据量大小")]),v._v(" "),t("li",[v._v("拥塞窗口 是发送端的限制，发送端在还为未收到对端 ACK 之前还能发送的数据量大小")])]),v._v(" "),t("p",[v._v("它于发送窗口有什么关系呢？")]),v._v(" "),t("p",[v._v("真正的发送窗口大小 = 接收窗口大小 与 拥塞窗口大小的最小值。")]),v._v(" "),t("p",[v._v("如果接收窗口比拥塞窗口小，说明接收端处理能力不够，如果接收窗口比拥塞窗口大，那么表示接收端处理能力正常但是网络拥塞。")]),v._v(" "),t("p",[v._v("这也比较好理解，发送端能发送多少数据取决于")]),v._v(" "),t("ol",[t("li",[v._v("接收端能够接收多少数据 （接收窗口）")]),v._v(" "),t("li",[v._v("自己为了避免网络拥塞主动控制不要发送过多的数据  （拥塞窗口）")])]),v._v(" "),t("p",[v._v("拥塞窗口的值是维护在发送端本地内存中的一个值，发送端和接收端最大的在途字节数数据包的大小只能是 rwnd 和 cwnd 之间的最小值")]),v._v(" "),t("p",[t("strong",[v._v("拥塞算法的本质是控制拥塞窗口的大小")])]),v._v(" "),t("h4",{attrs:{id:"拥塞算法之一-慢启动"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拥塞算法之一-慢启动"}},[v._v("#")]),v._v(" 拥塞算法之一 慢启动")]),v._v(" "),t("p",[v._v("在连接建立开始时，应该发送多少数据包给接收端才是合适的呢？")]),v._v(" "),t("p",[v._v("刚开始不知道网络的环境，如果网络拥塞，发送过多的数据只会造成更大的延迟，所以 TCP 采用一种保守的方式，给拥塞窗口的初始值设置成很小的一个值，随着时间推移，每次发送的数据包在不丢包的情况下慢慢递增，这种机制叫做 "),t("strong",[v._v("慢启动")])]),v._v(" "),t("ol",[t("li",[v._v("第一步 三次握手交换接收窗口的大小")]),v._v(" "),t("li",[v._v("第二步 双方各自初始化拥塞窗口大小 (cwnd)")]),v._v(" "),t("li",[v._v("第三步 cwnd 的初始值比较小，没收到一个 ACK ，cwnd 就加一，每经过一个 RTT，cwnd变为原来的2倍")])]),v._v(" "),t("p",[v._v("拥塞窗口不可能一直增大下去，当到达某一个阈值，增长速度就降下来，不要增长的那么块，这个阈值就是"),t("strong",[v._v("慢启动阈值")]),v._v(" (Slow Start threshold)。")]),v._v(" "),t("ul",[t("li",[v._v("当 cwnd < ssthresh 时，拥塞窗口呈指数型增长 （慢启动）")]),v._v(" "),t("li",[v._v("当 cwnd > ssthresh 时，拥塞窗口呈线性增长 （拥塞避免）")])]),v._v(" "),t("h4",{attrs:{id:"拥塞避免"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拥塞避免"}},[v._v("#")]),v._v(" "),t("strong",[v._v("拥塞避免")])]),v._v(" "),t("p",[v._v("当 cwnd > ssthresh 时，拥塞窗口进入「拥塞避免」阶段，在这个阶段，每一个往返 RTT，拥塞窗口大约增加 1 个 MSS 大小，直到检测到拥塞为止")]),v._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://user-gold-cdn.xitu.io/2019/4/12/16a1126f794fdf38?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"img"}}),v._v(" "),t("p",[v._v("它与慢启动区别是：")]),v._v(" "),t("ul",[t("li",[v._v("慢启动是每收到一个 ACK，拥塞窗口 cwnd 就加一，也就是每经过一个 RTT 就增大一倍")]),v._v(" "),t("li",[v._v("拥塞避免是每经过一个 RTT，才将拥塞窗口加一，不管期间收到多少 ACK")])]),v._v(" "),t("h4",{attrs:{id:"快速重传和选择确认"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#快速重传和选择确认"}},[v._v("#")]),v._v(" 快速重传和选择确认")]),v._v(" "),t("p",[v._v("前面介绍重传的时间间隔，要等几百毫秒才会进行第一次重传。")]),v._v(" "),t("p",[v._v("快速重传：当收到三个或以上重复的 ACK ，就意识到可能之前发的包丢了，马上进行重传，而不用等定时器超时之后再重传。")]),v._v(" "),t("p",[v._v("快速重传解决了需要重传的问题，但是无法确认是哪一个包需要重传，于是在 TCP 首部可选项中加入了 SACK 选项，在其中告诉发送端哪个包丢失了。")]),v._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://user-gold-cdn.xitu.io/2019/4/12/16a1126f8b380ed9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"img"}}),v._v(" "),t("h4",{attrs:{id:"快速恢复"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#快速恢复"}},[v._v("#")]),v._v(" 快速恢复")]),v._v(" "),t("p",[v._v("当收到三个重复的 ACK时，进入快速恢复阶段。解释为当前网络轻微拥塞。")]),v._v(" "),t("ul",[t("li",[v._v("ssthresh 降为cwnd 的一半：ssthresh = cwnd / 2")]),v._v(" "),t("li",[v._v("拥塞窗口cwnd 设置为 ssthresh")]),v._v(" "),t("li",[v._v("拥塞窗口线性增加")])]),v._v(" "),t("p",[t("strong",[v._v("总结")])]),v._v(" "),t("p",[v._v("拥塞控制算法：")]),v._v(" "),t("ul",[t("li",[v._v("慢启动：拥塞窗口初始值是一个很小的值，每经过一个 RTT 翻倍")]),v._v(" "),t("li",[v._v("拥塞避免：当拥塞窗口增大到一个阈值时，拥塞窗口从指数增长变为线性增长")]),v._v(" "),t("li",[v._v("快速重传：当收到三个以上的重复 ACK 时，马上进行重传而不需要等到超时再重传。")]),v._v(" "),t("li",[v._v("快速恢复：当收到三个以上的重复ACK时，进入快速恢复阶段，拥塞窗口变为cwnd 的一半，然后进入线性增长阶段")])])])}),[],!1,null,null,null);_.default=r.exports}}]);