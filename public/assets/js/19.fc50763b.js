(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{498:function(v,_,t){"use strict";t.r(_);var p=t(4),r=Object(p.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[v._v("首先来了解一下JavaScript 的数据是怎么存储的。")]),v._v(" "),t("p",[v._v("JavaScript 在执行过程中有三种内存空间：代码空间、栈空间和堆空间。")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("代码空间")]),v._v(" "),t("p",[v._v("用来存储可执行代码")])]),v._v(" "),t("li",[t("p",[v._v("栈空间")]),v._v(" "),t("p",[v._v("即调用栈，用来存储执行上下文。执行上下文中保存 "),t("strong",[v._v("原始类型")]),v._v(" 的数据，引用类型的数据保存在堆空间，执行上下文中变量保存的其实是内存地址。")])]),v._v(" "),t("li",[t("p",[v._v("堆空间")]),v._v(" "),t("p",[v._v("用来保存引用类型的数据。")])])]),v._v(" "),t("blockquote",[t("p",[v._v("闭包")]),v._v(" "),t("p",[v._v("前面提到原始类型的数据保存在栈空间，引用类型保存在堆空间，那么对于闭包中的数据保存在哪里呢？")]),v._v(" "),t("p",[v._v('实际上JavaScript 引擎在编译的时候，会对函数的内部函数进行词法扫描，如果发现其引用了外部变量，JavaScript 引擎就会判断其是一个闭包，会在堆空间中创建一个 “closure" 的内部对象，将引用的变量保存起来，如果还引用了其他的外部变量，也会被添加到 closure 对象中。')]),v._v(" "),t("p",[v._v("因此当执行上下文销毁的时候，闭包中的变量依然保存在内存中。")])]),v._v(" "),t("p",[t("strong",[v._v("垃圾回收")])]),v._v(" "),t("ul",[t("li",[t("p",[v._v("栈空间内存回收，是销毁执行上下文。调用栈中有一个记录当前执行状态的指针（ESP），当函数执行完后，需要销毁当前执行上下文，只需要将ESP 指针下移。后来新的执行上下文会直接覆盖掉原来的内容。")])]),v._v(" "),t("li",[t("p",[v._v("堆空间内存回收")]),v._v(" "),t("p",[v._v("首先了解 "),t("strong",[v._v("代际假说")]),v._v("，后续的垃圾回收策略都是建立在该假说的基础上。")]),v._v(" "),t("p",[t("strong",[v._v("代际假说")]),v._v(" 有两个特点：")]),v._v(" "),t("ol",[t("li",[v._v("大多数对象在内存中存活时间很短，简单来说很多内存一经分配很快就会变得不可访问")]),v._v(" "),t("li",[v._v("不死的对象会存活更久")])])])]),v._v(" "),t("p",[v._v("V8 中把堆分为两部分："),t("strong",[v._v("新生代")]),v._v(" 和 "),t("strong",[v._v("老生代")]),v._v("。"),t("strong",[v._v("新生代中存放的是生存时间比较短的对象，老生代存放的是生存时间比较长的对象")])]),v._v(" "),t("p",[v._v("新生代的容量比较小，一般只有1~8M 的容量，而老生代中支持的容量就比较大了，对于这两个区域，V8 分别使用了两个垃圾回收器：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("主垃圾回收器：用来回收老生代中的内存")])]),v._v(" "),t("li",[t("strong",[v._v("副垃圾回收器：用来回收新生代中的内存")])])]),v._v(" "),t("p",[v._v("垃圾回收器通常都有一套共同的执行流程：")]),v._v(" "),t("ol",[t("li",[v._v("标记内存空间中可回收对象和不可回收对象")]),v._v(" "),t("li",[v._v("回收可回收对象占用的内存。其实就是在所有标记完成后，一次性清理可回收对象。")]),v._v(" "),t("li",[v._v("内存整理。这一步是可选的，一般来说频繁的回收内存之后，内存中会产生大量的不连续空间，"),t("strong",[v._v("即内存碎片")]),v._v("。当要分配较大的内存对象时可能会出现内存不足的情况，因此需要整理这些内存碎片。")])]),v._v(" "),t("p",[v._v("副垃圾回收器：")]),v._v(" "),t("p",[v._v("​\t新生代用 "),t("strong",[v._v("Scavenge")]),v._v(" 算法，即将新生代区域对半划分为两个区域：对象区域和空闲区域。")]),v._v(" "),t("p",[v._v("​\t新产生的对象会被放入对象区域，当对象区域快要满的时候会进行一次垃圾回收。")]),v._v(" "),t("p",[v._v("​\t垃圾回收过程中，先对对象区域中的垃圾作标记，标记完成后，进入垃圾清理阶段，将存活的对象复制到空闲区域，同时也会把这些对象有序的排列起来，相当于完成了内存整理的工作。复制完成后将空闲区域和对象区域进行角色反转，即原来的对象区域变成空闲区域，空闲区域变成对象区域，这样就完成了垃圾回收的操作。由于每次垃圾回收过程中都需要将存活的对象复制到空闲区域，需要时间成本，如果区域设置过大就会影响执行效率，因此新生代区域一般设置的比较小。")]),v._v(" "),t("p",[v._v("也正是因为新生代的空间不大，很容易就被存活的对象占满，为此 JavaScript 引擎使用了 "),t("strong",[v._v("对象晋升策略")]),v._v("。经过两次垃圾回收还存活的对象会晋升到老生代中。")]),v._v(" "),t("p",[v._v("主垃圾回收器：")]),v._v(" "),t("p",[v._v("​\t老生代中除了新生代晋升过来的对象，还有一些比较大的对象会直接被分配到老生代中。因此老生代中对象的特点时占用空间比较大，存活时间长。")]),v._v(" "),t("p",[v._v("​\t因此主垃圾回收器使用的 "),t("strong",[v._v("标记-清除算法")]),v._v("来进行垃圾回收。将内存中的垃圾数据进行标记，清除阶段将标记的对象清除。不过对一块内存多次进行标记清除算法后会产生大量内存碎片，因此又出现了 "),t("strong",[v._v("标记-整理算法")]),v._v("。标记阶段仍然与标记清除算法阶段一样，但后续清理过程不是直接对可回收对象进行清理，而是让所有可存活对象往一边移动，然后直接清除边界外的内存。")]),v._v(" "),t("p",[t("strong",[v._v("全停顿")])]),v._v(" "),t("p",[v._v("当执行垃圾回收算法时，需要将正在执行的 JS 脚本暂停，等垃圾回收完成之后在恢复执行，这种行为称作 "),t("strong",[v._v("全停顿")]),v._v("。")]),v._v(" "),t("p",[v._v("V8新生代执行垃圾回收时，由于空间较小，存活的对象较少，全停顿带来的影响不大。但对于老生代来说，全停顿会造成页面卡顿。")]),v._v(" "),t("p",[v._v("为了降低全停顿带来的影响，V8"),t("strong",[v._v("使用了增量标记算法")]),v._v("，将标记过程分为一个个子标记过程，同时让垃圾回收标记和 JS 应用逻辑交替执行，知道标记阶段完成。这样将一个完整的垃圾回收过程拆分为许多个小的子任务，而子任务的执行时间比较短，可以穿插到 JS 任务中间执行，这样就不会因为垃圾回收而感受到页面卡顿了。")])])}),[],!1,null,null,null);_.default=r.exports}}]);