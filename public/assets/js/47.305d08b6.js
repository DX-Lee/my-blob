(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{528:function(_,v,e){"use strict";e.r(v);var l=e(4),a=Object(l.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h4",{attrs:{id:"tcp-nagle算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp-nagle算法"}},[_._v("#")]),_._v(" TCP Nagle算法")]),_._v(" "),e("p",[_._v("Nagle 算法主要是为了减少频繁发送小包给对方，是应用在发送端的。")]),_._v(" "),e("p",[_._v("Nagle 算法的要求：")]),_._v(" "),e("p",[_._v("第一次发送包是，无论是多小的包也会立刻发送。")]),_._v(" "),e("p",[_._v("后面发送数据时需要满足以下要求才可以发送：")]),_._v(" "),e("ul",[e("li",[_._v("数据包达到 MSS 大小。")]),_._v(" "),e("li",[_._v("收到之前发送数据包的ACK。")])]),_._v(" "),e("p",[e("strong",[_._v("Nagle算法的意义")])]),_._v(" "),e("p",[_._v("Nagle 算法的作用是为了减少小包在客户端和服务端之间传输。一个包的TCP头和IP头加起来至少有40字节，如果携带的数据非常小的话就比较浪费了。Nagle 算法在通信时延较小的场景下意义不大，在 Nagle 算法中 ACK 返回的越快，下次数据发送就越早。")]),_._v(" "),e("p",[_._v("Nagle算法是时代的产物：Nagle 算法出现的时候网络带宽都很小，当有大量小包传输时，很容易将带宽占满，出现丢包重传等现象。因此对 ssh 这种交互式的应用场景，选择开启 Nagle 算法可以使得不再那么频繁的发送小包，而是合并到一起，代价是稍微有一些延迟。现在的 ssh 客户端已经默认关闭了 Nagle 算法")]),_._v(" "),e("p",[e("strong",[_._v("延迟确认")])]),_._v(" "),e("p",[_._v("如果收到一个数据包以后暂时没有数据要发给对端，那么他可以等待一段时间再确认，如果这段时间内刚好有数据发送给对端，ACK 就可以随着数据一起发送出去了。如果超时也没有数据要发送，也要发送 ACK，以免对端以为丢包了。这种方式就是 "),e("strong",[_._v("延迟确认")]),_._v("。TCP 要求 ACK 延迟的时延必须小于500ms，一般操作系统实现都不会超过200ms。")]),_._v(" "),e("p",[_._v('有一些场景收到之后需要立刻回复 ACK，不能 "延迟确认":')]),_._v(" "),e("ul",[e("li",[_._v("如果接受到了一个大于 frame 的报文，且需要调整窗口大小")]),_._v(" "),e("li",[_._v("处于 quickack 模式（tcp_in_quickack_mode）")]),_._v(" "),e("li",[_._v("收到乱序包")])]),_._v(" "),e("p",[_._v("其他情况一律使用延迟确认模式")]),_._v(" "),e("p",[_._v("Nagle 算法和延迟确认本身没有什么问题，但是两个一起用就会出现严重的性能问题了。Nagle 攒着发，延迟确认收到包不立刻回。")])])}),[],!1,null,null,null);v.default=a.exports}}]);